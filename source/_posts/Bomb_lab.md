---
title: Bomb_lab
date: 2018-11-09 17:16:00
categories:
 - 学习笔记
 - 实验
tags: 
 - CS:APP
 - 汇编
---
### phase_5
```bash
    disas phase_5
```
生成下面的汇编代码，可见，需要读入一个长度为6的字符串
```
    0x0000000000401062 <+0>:     push   %rbx
    0x0000000000401063 <+1>:     sub    $0x20,%rsp
    0x0000000000401067 <+5>:     mov    %rdi,%rbx
    0x000000000040106a <+8>:     mov    %fs:0x28,%rax
    0x0000000000401073 <+17>:    mov    %rax,0x18(%rsp)
    0x0000000000401078 <+22>:    xor    %eax,%eax
    0x000000000040107a <+24>:    callq  0x40131b <string_length>
    0x000000000040107f <+29>:    cmp    $0x6,%eax
    0x0000000000401082 <+32>:    je     0x4010d2 <phase_5+112>
    0x0000000000401084 <+34>:    callq  0x40143a <explode_bomb>
```
从下面这段，是一个循环，对输入字符串进行一个变换，得到s.其变换为是`s[i] = p[input[i] & 0xf] `，p是程序内含的一个模式串.
```
   0x000000000040108b <+41>:    movzbl (%rbx,%rax,1),%ecx
   0x000000000040108f <+45>:    mov    %cl,(%rsp)
   0x0000000000401092 <+48>:    mov    (%rsp),%rdx
   0x0000000000401096 <+52>:    and    $0xf,%edx
   0x0000000000401099 <+55>:    movzbl 0x4024b0(%rdx),%edx
   0x00000000004010a0 <+62>:    mov    %dl,0x10(%rsp,%rax,1)
   0x00000000004010a4 <+66>:    add    $0x1,%rax
   0x00000000004010a8 <+70>:    cmp    $0x6,%rax
   0x00000000004010ac <+74>:    jne    0x40108b <phase_5+41>
```
程序中提到了0x4024b0这个地址，由于&0xf意味取取其低4位值，因为模式串长度应为16，我们查看这个串.
```
    (gdb) x /16c 0x4024b0
    0x4024b0 <array.3449>:  109 'm' 97 'a'  100 'd' 117 'u' 105 'i' 101 'e' 114 'r' 115 's'
    0x4024b8 <array.3449+8>:        110 'n' 102 'f' 111 'o' 116 't' 118 'v' 98 'b'  121 'y' 108 'l'
```
继续看汇编代码,发现将生成的s与另一个位于0x4025be的字符串进行比较，必须相等.
```
   0x00000000004010b3 <+81>:    mov    $0x40245e,%esi
   0x00000000004010b8 <+86>:    lea    0x10(%rsp),%rdi
   0x00000000004010bd <+91>:    callq  0x401338 <strings_not_equal>
   0x00000000004010c2 <+96>:    test   %eax,%eax
   0x00000000004010c4 <+98>:    je     0x4010d9 <phase_5+119>
   0x00000000004010c6 <+100>:   callq  0x40143a <explode_bomb>
```
我们查看另一个串,可指其为flyers.
```
    (gdb) x /6c 0x40245e
    0x40245e:       102 'f' 108 'l' 121 'y' 101 'e' 114 'r' 115 's'
```
我们由此反解输入，例如'f'在p中下标为9，低四位1001，查表得低4位位1001的字符又'i'，依次进行，解得一组答案为"ionefg".

### phase_6
首先还是
```
    disas phase_6
```
从得出代码可以看出，读入了6个数字，且这6个数字互不相等.
```
    Dump of assembler code for function phase_6:
    0x00000000004010f4 <+0>:     push   %r14
    0x00000000004010f6 <+2>:     push   %r13
    0x00000000004010f8 <+4>:     push   %r12
    0x00000000004010fa <+6>:     push   %rbp
    0x00000000004010fb <+7>:     push   %rbx
    0x00000000004010fc <+8>:     sub    $0x50,%rsp
    0x0000000000401100 <+12>:    mov    %rsp,%r13
    0x0000000000401103 <+15>:    mov    %rsp,%rsi
    0x0000000000401106 <+18>:    callq  0x40145c <read_six_numbers>
    0x000000000040110b <+23>:    mov    %rsp,%r14
    0x000000000040110e <+26>:    mov    $0x0,%r12d
    0x0000000000401114 <+32>:    mov    %r13,%rbp
    0x0000000000401117 <+35>:    mov    0x0(%r13),%eax
    0x000000000040111b <+39>:    sub    $0x1,%eax
    0x000000000040111e <+42>:    cmp    $0x5,%eax
    0x0000000000401121 <+45>:    jbe    0x401128 <phase_6+52>
    0x0000000000401123 <+47>:    callq  0x40143a <explode_bomb>
    0x0000000000401128 <+52>:    add    $0x1,%r12d
    0x000000000040112c <+56>:    cmp    $0x6,%r12d
    0x0000000000401130 <+60>:    je     0x401153 <phase_6+95>
    0x0000000000401132 <+62>:    mov    %r12d,%ebx
    0x0000000000401135 <+65>:    movslq %ebx,%rax
    0x0000000000401138 <+68>:    mov    (%rsp,%rax,4),%eax
    0x000000000040113b <+71>:    cmp    %eax,0x0(%rbp)
    0x000000000040113e <+74>:    jne    0x401145 <phase_6+81>
    0x0000000000401140 <+76>:    callq  0x40143a <explode_bomb>
    0x0000000000401145 <+81>:    add    $0x1,%ebx
    0x0000000000401148 <+84>:    cmp    $0x5,%ebx
    0x000000000040114b <+87>:    jle    0x401135 <phase_6+65>
    0x000000000040114d <+89>:    add    $0x4,%r13
    0x0000000000401151 <+93>:    jmp    0x401114 <phase_6+32>
```
由下面代码可以看出，对输入的6个数进行了映射，```input[i] = 7 - input[i]```.
```
    0x000000000040115b <+103>:   mov    $0x7,%ecx
    0x0000000000401160 <+108>:   mov    %ecx,%edx
    0x0000000000401162 <+110>:   sub    (%rax),%edx
    0x0000000000401164 <+112>:   mov    %edx,(%rax)
    0x0000000000401166 <+114>:   add    $0x4,%rax
    0x000000000040116a <+118>:   cmp    %rsi,%rax
    0x000000000040116d <+121>:   jne    0x401160 <phase_6+108>
```
下面的代码，按照输入的6个数映射后的结果，取链表中对应的元素的6个指针放在一个数组中。
```
  0x000000000040116f <+123>:   mov    $0x0,%esi
   0x0000000000401174 <+128>:   jmp    0x401197 <phase_6+163>
   0x0000000000401176 <+130>:   mov    0x8(%rdx),%rdx
   0x000000000040117a <+134>:   add    $0x1,%eax
   0x000000000040117d <+137>:   cmp    %ecx,%eax
   0x000000000040117f <+139>:   jne    0x401176 <phase_6+130>
   0x0000000000401181 <+141>:   jmp    0x401188 <phase_6+148>
   0x0000000000401183 <+143>:   mov    $0x6032d0,%edx
   0x0000000000401188 <+148>:   mov    %rdx,0x20(%rsp,%rsi,2)
   0x000000000040118d <+153>:   add    $0x4,%rsi
   0x0000000000401191 <+157>:   cmp    $0x18,%rsi
   0x0000000000401195 <+161>:   je     0x4011ab <phase_6+183>
   0x0000000000401197 <+163>:   mov    (%rsp,%rsi,1),%ecx
   0x000000000040119a <+166>:   cmp    $0x1,%ecx
   0x000000000040119d <+169>:   jle    0x401183 <phase_6+143>
   0x000000000040119f <+171>:   mov    $0x1,%eax
   0x00000000004011a4 <+176>:   mov    $0x6032d0,%edx
   0x00000000004011a9 <+181>:   jmp    0x401176 <phase_6+130>
```
该链表头指针为$0x6032d0,查看得知该链表元素为
```
    (gdb) p /x 0x6032d0
    $1 = 0x6032d0
    (gdb) p /x *0x6032d0
    $2 = 0x14c
    (gdb) p /x *(0x6032d0 + 8)
    $3 = 0x6032e0
    (gdb) p /x *(0x6032e0)
    $4 = 0xa8
    (gdb) p /x *(0x6032e0 + 8)
    $5 = 0x6032f0
    (gdb) p /x *(0x6032f0)
    $6 = 0x39c
    (gdb) p /x *(0x6032f0 + 8)
    $7 = 0x603300
    (gdb) p /x *(0x603300)
    $8 = 0x2b3
    (gdb) p /x *(0x603300 + 8)
    $9 = 0x603310
    (gdb) p /x *(0x603310)
    $10 = 0x1dd
    (gdb) p /x *(0x603310 + 8)
    $11 = 0x603320
    (gdb) p /x *(0x603320)
    $12 = 0x1bb
    (gdb) p /x *(0x603320 + 8)
    $13 = 0x0
```
之后的代码中，可以看出，用按顺序选出的节点指针，建立一个新链表，该链表为降序.
```
    0x00000000004011ab <+183>:   mov    0x20(%rsp),%rbx
    0x00000000004011b0 <+188>:   lea    0x28(%rsp),%rax
    0x00000000004011b5 <+193>:   lea    0x50(%rsp),%rsi
    0x00000000004011ba <+198>:   mov    %rbx,%rcx
    0x00000000004011bd <+201>:   mov    (%rax),%rdx
    0x00000000004011c0 <+204>:   mov    %rdx,0x8(%rcx)
    0x00000000004011c4 <+208>:   add    $0x8,%rax
    0x00000000004011c8 <+212>:   cmp    %rsi,%rax
    0x00000000004011cb <+215>:   je     0x4011d2 <phase_6+222>
    0x00000000004011cd <+217>:   mov    %rdx,%rcx
    0x00000000004011d0 <+220>:   jmp    0x4011bd <phase_6+201>
    0x00000000004011d2 <+222>:   movq   $0x0,0x8(%rdx)
    0x00000000004011da <+230>:   mov    $0x5,%ebp
    0x00000000004011df <+235>:   mov    0x8(%rbx),%rax
    0x00000000004011e3 <+239>:   mov    (%rax),%eax
    0x00000000004011e5 <+241>:   cmp    %eax,(%rbx)
    0x00000000004011e7 <+243>:   jge    0x4011ee <phase_6+250>
    0x00000000004011e9 <+245>:   callq  0x40143a <explode_bomb>
    0x00000000004011ee <+250>:   mov    0x8(%rbx),%rbx
    0x00000000004011f2 <+254>:   sub    $0x1,%ebp
    0x00000000004011f5 <+257>:   jne    0x4011df <phase_6+235>
```
要使链表为降序，映射后的6个数应该为3，4，5，6，1，2，那么原输入应该为4，3，2，1，6，5

到此，二进制炸弹的解码就结束了，改实验具有一定的难度，十分考验逻辑推理和汇编理解能力.